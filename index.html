<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D D&D Dice Roller</title>
  <link rel="icon" href="data:,">
  <style>
    body {
      margin: 0;
      background-color: #1a1a1a; /* Dark background */
      color: #fafafa;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #controls {
      margin: 20px 0;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
    }
    .dice-control {
      background-color: #8B0000; /* Red button background */
      padding: 10px;
      margin: 5px;
      border-radius: 5px;
      display: flex;
      align-items: center;
      border: 1px solid #440000; /* Slightly darker red border */
    }
    .dice-control span {
      margin: 0 10px;
      font-weight: bold;
    }
    .dice-control button {
      background-color: #8B0000;
      color: #fafafa;
      border: 1px solid #440000;
      padding: 5px 10px;
      cursor: pointer;
      font-weight: bold;
      border-radius: 3px;
    }
    .dice-control button:hover {
      background-color: #6d0101;
    }

    /* 3D viewer with red border */
    #canvas-container {
      width: 80%;
      height: 400px;
      border: 2px solid red; /* Red border */
      position: relative;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(255,255,255,0.1);
      margin-bottom: 10px;
      background-color: #000;
    }

    /* Buttons remain red */
    #roll-button,
    #copy-log-button {
      margin: 10px 5px;
      padding: 10px 20px;
      background-color: #8B0000;
      color: #fafafa;
      border: 1px solid #440000;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
    }
    #roll-button:hover,
    #copy-log-button:hover {
      background-color: #6d0101;
    }

    /* Roll Results container with red border */
    #results-header {
      margin: 0 0 5px 0;
      padding: 5px 0;
      font-size: 16px;
      font-weight: bold;
      text-align: center;
      width: 80%;
      color: #fafafa;
    }
    #results {
      background-color: #2a2a2a;
      padding: 10px;
      border: 2px solid red; /* Red border */
      border-radius: 5px;
      width: 80%;
      max-height: 300px; /* Adjust as desired */
      overflow-y: auto;
      color: #fafafa;
      margin-bottom: 10px;
    }
    #roll-log {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    #roll-log li {
      padding: 8px;
      margin-bottom: 5px;
      background-color: #333;
      border-radius: 4px;
    }
    #roll-log li:nth-child(odd) {
      background-color: #2a2a2a;
    }

    /* Dice result backgrounds (dark red, blue, purple, green, yellow, orange) */
    .d4-result    { background-color: rgba(139, 0, 0, 0.6); }    /* Dark Red */
    .d6-result    { background-color: rgba(0, 0, 139, 0.6); }    /* Blue (DarkBlue) */
    .d8-result    { background-color: rgba(75, 0, 130, 0.6); }   /* Purple (Indigo) */
    .d10-result   { background-color: rgba(0, 100, 0, 0.6); }    /* Green (DarkGreen) */
    .d12-result   { background-color: rgba(204, 204, 0, 0.6); }  /* Yellow (#CCCC00) */
    .d20-result   { background-color: rgba(255, 140, 0, 0.6); }  /* Orange (DarkOrange) */

    .total-result {
      background-color: #8b5a2b;
      color: #fafafa;
      padding: 3px 8px;
      border-radius: 4px;
      margin-left: 8px;
      font-weight: bold;
    }

    /* Dice Usage Information section with red border */
    #dice-info {
      background-color: #2a2a2a;
      color: #fafafa;
      border: 2px solid red; /* Red border */
      border-radius: 5px;
      width: 80%;
      padding: 10px;
      margin-top: 10px;
      max-height: 300px;
      overflow-y: auto;
    }
    #dice-info h2, #dice-info h3 {
      color: #fafafa;
      text-align: center;
      margin: 10px 0 5px;
    }
    #dice-info p {
      margin: 5px 0;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <!-- Dice Controls -->
  <div id="controls">
    <div class="dice-control" data-type="d4">
      <button class="remove">-</button>
      <span>D4: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d6">
      <button class="remove">-</button>
      <span>D6: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d8">
      <button class="remove">-</button>
      <span>D8: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d10">
      <button class="remove">-</button>
      <span>D10: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d12">
      <button class="remove">-</button>
      <span>D12: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d20">
      <button class="remove">-</button>
      <span>D20: 0</span>
      <button class="add">+</button>
    </div>
  </div>

  <!-- 3D Dice Container -->
  <div id="canvas-container"></div>

  <!-- Roll & Copy Log Buttons -->
  <div>
    <button id="roll-button">Roll Dice</button>
    <button id="copy-log-button">Copy Log</button>
  </div>

  <!-- Roll Results -->
  <div id="results-header">Roll Results</div>
  <div id="results">
    <ul id="roll-log"></ul>
  </div>

  <!-- Dice Usage Information -->
  <div id="dice-info">
    <h2>Dice Usage Information</h2>
    <div class="dice-section">
      <h3>D4 (4-sided die)</h3>
      <p><strong>Damage:</strong> Used for low-damage rolls (e.g. daggers, minor spells) and small healing effects.</p>
      <p><strong>Bonus:</strong> Sometimes adds a small bonus to d20 rolls (e.g. Bless, Guidance).</p>
    </div>
    <div class="dice-section">
      <h3>D6 (6-sided die)</h3>
      <p><strong>Damage:</strong> Frequently rolled for weapon damage (shortswords, handaxes) and big spells (Fireball with multiple d6s).</p>
      <p><strong>Ability Scores:</strong> Commonly used for 4d6 drop-lowest ability score generation.</p>
      <p><strong>Hit Dice:</strong> Wizards/Sorcerers use a d6 for HP growth.</p>
    </div>
    <div class="dice-section">
      <h3>D8 (8-sided die)</h3>
      <p><strong>Damage:</strong> Standard for one-handed martial weapons (longswords, rapiers) and many spells.</p>
      <p><strong>Hit Dice:</strong> Mid-tier classes (Cleric, Druid, Rogue, Bard, Monk).</p>
    </div>
    <div class="dice-section">
      <h3>D10 (10-sided die)</h3>
      <p><strong>Damage:</strong> Heavy weapons (e.g. glaives, halberds) and potent spells (Inflict Wounds). Also used for percentile rolls (d100).</p>
      <p><strong>Hit Dice:</strong> Fighter, Paladin, Ranger.</p>
    </div>
    <div class="dice-section">
      <h3>D12 (12-sided die)</h3>
      <p><strong>Damage:</strong> Big hits like a greataxe or certain high-level effects.</p>
      <p><strong>Hit Dice:</strong> Barbarians are the only class with a d12.</p>
    </div>
    <div class="dice-section">
      <h3>D20 (20-sided die)</h3>
      <p><strong>Core Mechanic:</strong> Rolled for attacks, ability checks, saving throws, and initiative. A natural 20 is a critical success, while a natural 1 is often a failure.</p>
    </div>
  </div>

  <!-- Three.js and Dice Roller Script -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    // Dimensions for the square platform
    const floorY = -0.5;
    const floorSize = 24;      // Black floor is 24x24
    const borderSize = 26;     // Red border is 26x26
    const halfSize = floorSize / 2; // For collision checks

    // Create a sprite with a smiley face drawn on a canvas
    function createSmileyFaceSprite() {
      const size = 256;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');

      // Clear / transparent background
      ctx.clearRect(0, 0, size, size);

      // Draw a yellow circle
      ctx.beginPath();
      ctx.arc(size / 2, size / 2, size / 2.5, 0, 2 * Math.PI);
      ctx.fillStyle = '#FFFF00';
      ctx.fill();

      // Eyes
      ctx.beginPath();
      ctx.arc(size / 3, size / 3, size / 15, 0, 2 * Math.PI);
      ctx.fillStyle = '#000000';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(2 * size / 3, size / 3, size / 15, 0, 2 * Math.PI);
      ctx.fill();

      // Mouth (arc from 0 to Math.PI => half-circle)
      ctx.beginPath();
      ctx.arc(size / 2, size / 2, size / 3, 0, Math.PI);
      ctx.lineWidth = size / 20;
      ctx.strokeStyle = '#000000';
      ctx.stroke();

      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(3, 3, 1); // Adjust size as needed
      return sprite;
    }

    // Custom geometry for the D10 (pentagonal trapezohedron)
    function createD10Geometry() {
      const alpha = 0.8;
      const phi = Math.PI / 10;
      const r = Math.sin(alpha);
      const cy = Math.cos(alpha);

      const top = [];
      const bottom = [];
      for (let i = 0; i < 5; i++) {
        let angleTop = (2 * Math.PI * i / 5) + phi;
        let angleBottom = (2 * Math.PI * i / 5) - phi;
        top.push(new THREE.Vector3(r * Math.cos(angleTop), cy, r * Math.sin(angleTop)));
        bottom.push(new THREE.Vector3(r * Math.cos(angleBottom), -cy, r * Math.sin(angleBottom)));
      }

      const vertices = [];
      for (let i = 0; i < 5; i++) {
        vertices.push(top[i].x, top[i].y, top[i].z);
      }
      for (let i = 0; i < 5; i++) {
        vertices.push(bottom[i].x, bottom[i].y, bottom[i].z);
      }

      const indices = [];
      for (let i = 0; i < 5; i++) {
        let t0 = i;
        let t1 = (i + 1) % 5;
        let b0 = i + 5;
        let b1 = ((i + 1) % 5) + 5;
        indices.push(t0, b0, t1);
        indices.push(b0, b1, t1);
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();
      return geometry;
    }

    window.addEventListener('load', function() {
      if (typeof THREE === 'undefined') {
        console.error('Three.js failed to load. Check your internet connection or the CDN link.');
        return;
      }

      // Scene setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      const container = document.getElementById('canvas-container');
      const camera = new THREE.PerspectiveCamera(
        75,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const pointLight = new THREE.PointLight(0xffffff, 1);
      pointLight.position.set(10, 10, 10);
      scene.add(pointLight);

      // Camera position
      camera.position.z = 18;
      camera.position.y = 8;

      // Starfield
      function createStars() {
        const starCount = 1000;
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        for (let i = 0; i < starCount; i++) {
          const x = Math.random() * 2000 - 1000;
          const y = Math.random() * 2000 - 1000;
          const z = Math.random() * 2000 - 1000;
          starVertices.push(x, y, z);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
      }
      createStars();

      // Red square border plane (26x26)
      const redPlaneGeometry = new THREE.PlaneGeometry(borderSize, borderSize);
      const redPlaneMaterial = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        roughness: 0.8,
        metalness: 0.2
      });
      const redPlane = new THREE.Mesh(redPlaneGeometry, redPlaneMaterial);
      redPlane.rotation.x = -Math.PI / 2;
      redPlane.position.y = floorY;
      scene.add(redPlane);

      // Black square floor plane (24x24)
      const blackPlaneGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
      const blackPlaneMaterial = new THREE.MeshStandardMaterial({
        color: 0x000000,
        roughness: 0.8,
        metalness: 0.2
      });
      const blackPlane = new THREE.Mesh(blackPlaneGeometry, blackPlaneMaterial);
      blackPlane.rotation.x = -Math.PI / 2;
      blackPlane.position.y = floorY + 0.01;
      scene.add(blackPlane);

      // Smiley face in the middle
      const smiley = createSmileyFaceSprite();
      smiley.position.set(0, floorY + 0.02, 0);
      scene.add(smiley);

      // Dice data
      const diceTypes = ['d4', 'd6', 'd8', 'd10', 'd12', 'd20'];
      const diceCounts = { d4: 0, d6: 0, d8: 0, d10: 0, d12: 0, d20: 0 };
      const dice = [];

      // Dark Red, Blue, Purple, Green, Yellow, Orange
      const diceColors = {
        d4:  0x8B0000, /* Dark Red */
        d6:  0x00008B, /* Dark Blue */
        d8:  0x4B0082, /* Purple (Indigo) */
        d10: 0x006400, /* Dark Green */
        d12: 0xCCCC00, /* Yellow-ish (#CCCC00) */
        d20: 0xFF8C00  /* Dark Orange */
      };

      const geometries = {
        d4:  new THREE.TetrahedronGeometry(1),
        d6:  new THREE.BoxGeometry(1.4, 1.4, 1.4),
        d8:  new THREE.OctahedronGeometry(1),
        d10: createD10Geometry(),
        d12: new THREE.DodecahedronGeometry(1),
        d20: new THREE.IcosahedronGeometry(1)
      };

      // Create a die with black wireframe edges
      function createDie(type) {
        const geometry = geometries[type];
        const color = diceColors[type];
        const material = new THREE.MeshStandardMaterial({
          color: color,
          metalness: 0.3,
          roughness: 0.2
        });
        const die = new THREE.Mesh(geometry, material);

        // Black wireframe for the edges
        const wireframeGeometry = new THREE.EdgesGeometry(geometry);
        const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
        const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
        die.add(wireframe);

        die.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );

        die.userData = {
          type: type,
          result: 0,
          velocity: new THREE.Vector3(0, 0, 0),
          angularVelocity: new THREE.Vector3(0, 0, 0),
          isRolling: false
        };
        return die;
      }

      function addDie(type) {
        if (diceCounts[type] < 10) {
          diceCounts[type]++;
          const die = createDie(type);
          dice.push(die);
          scene.add(die);
          positionDice();
          updateControls();
        }
      }

      function removeDie(type) {
        if (diceCounts[type] > 0) {
          diceCounts[type]--;
          const index = dice.findIndex(d => d.userData.type === type);
          if (index !== -1) {
            scene.remove(dice[index]);
            dice.splice(index, 1);
            positionDice();
            updateControls();
          }
        }
      }

      // Spread dice in a grid
      function positionDice() {
        if (dice.length === 0) return;
        const spacing = 3.0;
        const rows = Math.ceil(Math.sqrt(dice.length));
        const cols = Math.ceil(dice.length / rows);
        const offsetX = ((cols - 1) * spacing) / 2;
        const offsetZ = ((rows - 1) * spacing) / 2;
        dice.forEach((die, index) => {
          const row = Math.floor(index / cols);
          const col = index % cols;
          die.position.set(
            col * spacing - offsetX,
            0.6 + Math.random() * 0.2,
            row * spacing - offsetZ
          );
          const scale = 0.9 + Math.random() * 0.2;
          die.scale.set(scale, scale, scale);
          die.rotation.set(
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2
          );
        });
      }

      function updateControls() {
        diceTypes.forEach(type => {
          const control = document.querySelector(`.dice-control[data-type="${type}"] span`);
          if (control) {
            control.textContent = `${type.toUpperCase()}: ${diceCounts[type]}`;
          }
        });
      }

      function rollDice() {
        if (dice.length === 0) return;
        const rollButton = document.getElementById('roll-button');
        rollButton.disabled = true;
        prepareDiceForRoll();

        dice.forEach(die => {
          die.userData.isRolling = true;
          const sides = parseInt(die.userData.type.slice(1));
          die.userData.result = Math.floor(Math.random() * sides) + 1;
          die.userData.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 3,
            Math.random() * 5 + 3,
            (Math.random() - 0.5) * 3
          );
          die.userData.angularVelocity = new THREE.Vector3(
            (Math.random() - 0.5) * 25,
            (Math.random() - 0.5) * 25,
            (Math.random() - 0.5) * 25
          );
        });

        // After 2.5s, assume dice have settled
        setTimeout(() => {
          dice.forEach(die => {
            die.userData.isRolling = false;
          });
          displayResults();
          rollButton.disabled = false;
        }, 2500);
      }

      // Randomize initial position/rotation for dice before rolling
      function prepareDiceForRoll() {
        if (dice.length === 0) return;
        const spacing = 3.0;
        const rows = Math.ceil(Math.sqrt(dice.length));
        const cols = Math.ceil(dice.length / rows);
        const offsetX = ((cols - 1) * spacing) / 2;
        const offsetZ = ((rows - 1) * spacing) / 2;
        dice.forEach((die, index) => {
          const row = Math.floor(index / cols);
          const col = index % cols;
          die.position.set(
            col * spacing - offsetX + (Math.random() * 0.5 - 0.25),
            3 + Math.random(),
            row * spacing - offsetZ + (Math.random() * 0.5 - 0.25)
          );
          die.rotation.set(
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2
          );
        });
      }

      // Simple square collision check
      function updateDicePhysics(delta) {
        const gravity = new THREE.Vector3(0, -9.8, 0);

        dice.forEach(die => {
          if (!die.userData.isRolling) return;

          // Apply velocity
          die.position.addScaledVector(die.userData.velocity, delta);
          die.rotation.x += die.userData.angularVelocity.x * delta;
          die.rotation.y += die.userData.angularVelocity.y * delta;
          die.rotation.z += die.userData.angularVelocity.z * delta;

          // Gravity & damping
          die.userData.velocity.addScaledVector(gravity, delta);
          die.userData.velocity.multiplyScalar(0.98);
          die.userData.angularVelocity.multiplyScalar(0.98);

          // Floor collision
          const dieRadius = 0.8;
          if (die.position.y - dieRadius < floorY) {
            die.position.y = floorY + dieRadius;
            die.userData.velocity.y *= -0.5;
            die.userData.velocity.x *= 0.8;
            die.userData.velocity.z *= 0.8;
            die.userData.angularVelocity.x += (Math.random() - 0.5) * 5;
            die.userData.angularVelocity.z += (Math.random() - 0.5) * 5;
          }

          // Square boundary collisions
          if (die.position.x < -halfSize) {
            die.position.x = -halfSize;
            die.userData.velocity.x *= -0.5;
            die.userData.angularVelocity.x += (Math.random() - 0.5) * 10;
            die.userData.angularVelocity.y += (Math.random() - 0.5) * 10;
            die.userData.angularVelocity.z += (Math.random() - 0.5) * 10;
          }
          if (die.position.x > halfSize) {
            die.position.x = halfSize;
            die.userData.velocity.x *= -0.5;
            die.userData.angularVelocity.x += (Math.random() - 0.5) * 10;
            die.userData.angularVelocity.y += (Math.random() - 0.5) * 10;
            die.userData.angularVelocity.z += (Math.random() - 0.5) * 10;
          }
          if (die.position.z < -halfSize) {
            die.position.z = -halfSize;
            die.userData.velocity.z *= -0.5;
            die.userData.angularVelocity.x += (Math.random() - 0.5) * 10;
            die.userData.angularVelocity.y += (Math.random() - 0.5) * 10;
            die.userData.angularVelocity.z += (Math.random() - 0.5) * 10;
          }
          if (die.position.z > halfSize) {
            die.position.z = halfSize;
            die.userData.velocity.z *= -0.5;
            die.userData.angularVelocity.x += (Math.random() - 0.5) * 10;
            die.userData.angularVelocity.y += (Math.random() - 0.5) * 10;
            die.userData.angularVelocity.z += (Math.random() - 0.5) * 10;
          }
        });

        // Dice-to-dice collisions
        for (let i = 0; i < dice.length; i++) {
          if (!dice[i].userData.isRolling) continue;
          for (let j = i + 1; j < dice.length; j++) {
            if (!dice[j].userData.isRolling) continue;
            const die1 = dice[i];
            const die2 = dice[j];
            const dx = die2.position.x - die1.position.x;
            const dy = die2.position.y - die1.position.y;
            const dz = die2.position.z - die1.position.z;
            const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
            const minDist = 1.8;
            if (distance < minDist) {
              // Normal vector
              const nx = dx / distance;
              const ny = dy / distance;
              const nz = dz / distance;
              // Push them apart
              const overlap = (minDist - distance) / 2;
              die1.position.x -= nx * overlap;
              die1.position.y -= ny * overlap;
              die1.position.z -= nz * overlap;
              die2.position.x += nx * overlap;
              die2.position.y += ny * overlap;
              die2.position.z += nz * overlap;

              // Bounce velocities
              const dot1 = die1.userData.velocity.x * nx + die1.userData.velocity.y * ny + die1.userData.velocity.z * nz;
              const dot2 = die2.userData.velocity.x * nx + die2.userData.velocity.y * ny + die2.userData.velocity.z * nz;
              const bounce = 0.7;
              die1.userData.velocity.x += (dot2 - dot1) * nx * bounce;
              die1.userData.velocity.y += (dot2 - dot1) * ny * bounce;
              die1.userData.velocity.z += (dot2 - dot1) * nz * bounce;
              die2.userData.velocity.x += (dot1 - dot2) * nx * bounce;
              die2.userData.velocity.y += (dot1 - dot2) * ny * bounce;
              die2.userData.velocity.z += (dot1 - dot2) * nz * bounce;

              // Extra spin
              const spinAmount = 5.0;
              die1.userData.angularVelocity.x += (Math.random() - 0.5) * spinAmount;
              die1.userData.angularVelocity.y += (Math.random() - 0.5) * spinAmount;
              die1.userData.angularVelocity.z += (Math.random() - 0.5) * spinAmount;
              die2.userData.angularVelocity.x += (Math.random() - 0.5) * spinAmount;
              die2.userData.angularVelocity.y += (Math.random() - 0.5) * spinAmount;
              die2.userData.angularVelocity.z += (Math.random() - 0.5) * spinAmount;
            }
          }
        }

        // Snap dice to rest if almost stopped
        dice.forEach(die => {
          if (!die.userData.isRolling &&
              die.userData.velocity.length() < 0.1 &&
              die.userData.angularVelocity.length() < 0.1) {
            const type = die.userData.type;
            const euler = new THREE.Euler().setFromQuaternion(die.quaternion);
            // Snap rotation (rough approximation)
            if (type === 'd6') {
              euler.x = Math.round(euler.x / (Math.PI / 2)) * (Math.PI / 2);
              euler.z = Math.round(euler.z / (Math.PI / 2)) * (Math.PI / 2);
            } else {
              euler.x = Math.round(euler.x / (Math.PI / 4)) * (Math.PI / 4);
              euler.y = Math.round(euler.y / (Math.PI / 4)) * (Math.PI / 4);
              euler.z = Math.round(euler.z / (Math.PI / 4)) * (Math.PI / 4);
            }
            die.quaternion.setFromEuler(euler);
            die.userData.velocity.set(0, 0, 0);
            die.userData.angularVelocity.set(0, 0, 0);
          }
        });
      }

      function displayResults() {
        const rollLog = document.getElementById('roll-log');
        const resultsByType = {};
        let totalSum = 0;

        dice.forEach(die => {
          const type = die.userData.type;
          const result = die.userData.result;
          if (!resultsByType[type]) {
            resultsByType[type] = [];
          }
          resultsByType[type].push(result);
          totalSum += result;
        });

        let resultHTML = '';
        for (const type in resultsByType) {
          if (resultsByType[type].length > 0) {
            resultHTML += `<span class="${type}-result">${type.toUpperCase()}: [${resultsByType[type].join(', ')}]</span> `;
          }
        }
        resultHTML += `<span class="total-result">Total: ${totalSum}</span>`;

        const logEntry = document.createElement('li');
        logEntry.innerHTML = resultHTML;
        rollLog.insertBefore(logEntry, rollLog.firstChild);

        // Keep only the most recent 10 rolls
        while (rollLog.children.length > 10) {
          rollLog.removeChild(rollLog.lastChild);
        }
      }

      // Copy Log functionality
      function copyLog() {
        const rollLog = document.getElementById('roll-log');
        let logText = '';
        for (let i = 0; i < rollLog.children.length; i++) {
          logText += rollLog.children[i].textContent.trim() + '\n';
        }
        navigator.clipboard.writeText(logText)
          .then(() => {
            alert('Roll log copied to clipboard!');
          })
          .catch(err => {
            console.error('Failed to copy log:', err);
          });
      }

      // Event listeners
      document.querySelectorAll('.dice-control .add').forEach(button => {
        button.addEventListener('click', function() {
          const type = this.parentElement.dataset.type;
          addDie(type);
        });
      });
      document.querySelectorAll('.dice-control .remove').forEach(button => {
        button.addEventListener('click', function() {
          const type = this.parentElement.dataset.type;
          removeDie(type);
        });
      });
      document.getElementById('roll-button').addEventListener('click', rollDice);
      document.getElementById('copy-log-button').addEventListener('click', copyLog);

      let lastTime = 0;
      function animate(time) {
        requestAnimationFrame(animate);
        const delta = Math.min((time - lastTime) / 1000, 0.1);
        lastTime = time;
        updateDicePhysics(delta);
        renderer.render(scene, camera);
      }
      animate(0);

      window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });

      // Add one of each die to start
      addDie('d4');
      addDie('d6');
      addDie('d8');
      addDie('d10');
      addDie('d12');
      addDie('d20');
    });
  </script>
</body>
</html>
