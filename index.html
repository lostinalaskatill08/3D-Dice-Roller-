<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D D&D Dice Roller</title>
    <link rel="icon" href="data:,">
    <style>
        body {
            margin: 0;
            background-color: #1a1a1a;
            color: #fff;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-y: auto; /* Enable vertical scrolling */
            padding-bottom: 20px; /* Add some padding at the bottom */
        }
        #controls {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            width: 90%;
            max-width: 800px;
        }
        .dice-control {
            padding: 10px;
            margin: 5px;
            border-radius: 5px;
            display: flex;
            align-items: center;
        }
        .dice-control[data-type="d4"] { background-color: #ff4444; }
        .dice-control[data-type="d6"] { background-color: #44ff44; }
        .dice-control[data-type="d8"] { background-color: #4444ff; }
        .dice-control[data-type="d10"] { background-color: #ff44ff; }
        .dice-control[data-type="d12"] { background-color: #ffff44; }
        .dice-control[data-type="d20"] { background-color: #44ffff; }
        
        .dice-control span {
            margin: 0 10px;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .dice-control button {
            background-color: white;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            font-weight: bold;
            border-radius: 3px;
        }
        .dice-control button:hover {
            background-color: #e6e6e6;
        }
        #canvas-container {
            width: 90%;
            height: 50vh; /* Use viewport height for better scaling */
            border: 2px solid #444;
            background-color: #000;
            position: relative;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(255,255,255,0.1);
            margin-bottom: 15px;
        }
        #roll-button {
            margin: 15px 0;
            padding: 12px 24px;
            background-color: #ff9900;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }
        #roll-button:hover {
            background-color: #ffaa33;
            transform: translateY(-2px);
        }
        #roll-button:active {
            transform: translateY(1px);
        }
        #results {
            background-color: #222;
            padding: 15px;
            border: 1px solid #444;
            border-radius: 8px;
            width: 90%;
            max-width: 800px;
            height: 180px; /* Fixed height */
            overflow-y: auto; /* Enable vertical scrolling in results area */
            color: #fff;
            margin-top: 15px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            margin-bottom: 30px; /* Add more space at bottom */
        }
        #results h3 {
            margin: 0 0 10px 0;
            color: #ff9900;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
            position: sticky;
            top: 0;
            background-color: #222;
            z-index: 1;
        }
        #roll-log {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        #roll-log li {
            padding: 8px;
            margin-bottom: 5px;
            background-color: #333;
            border-radius: 4px;
        }
        #roll-log li:nth-child(odd) {
            background-color: #2a2a2a;
        }
        .die-result {
            display: inline-block;
            padding: 3px 6px;
            margin: 0 3px;
            border-radius: 3px;
            font-weight: bold;
        }
        .d4-result { background-color: rgba(255, 68, 68, 0.3); }
        .d6-result { background-color: rgba(68, 255, 68, 0.3); }
        .d8-result { background-color: rgba(68, 68, 255, 0.3); }
        .d10-result { background-color: rgba(255, 68, 255, 0.3); }
        .d12-result { background-color: rgba(255, 255, 68, 0.3); }
        .d20-result { background-color: rgba(68, 255, 255, 0.3); }
        .total-result {
            background-color: #ff9900;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            margin-left: 8px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div class="dice-control" data-type="d4">
            <button class="remove">-</button>
            <span>D4: 0</span>
            <button class="add">+</button>
        </div>
        <div class="dice-control" data-type="d6">
            <button class="remove">-</button>
            <span>D6: 0</span>
            <button class="add">+</button>
        </div>
        <div class="dice-control" data-type="d8">
            <button class="remove">-</button>
            <span>D8: 0</span>
            <button class="add">+</button>
        </div>
        <div class="dice-control" data-type="d10">
            <button class="remove">-</button>
            <span>D10: 0</span>
            <button class="add">+</button>
        </div>
        <div class="dice-control" data-type="d12">
            <button class="remove">-</button>
            <span>D12: 0</span>
            <button class="add">+</button>
        </div>
        <div class="dice-control" data-type="d20">
            <button class="remove">-</button>
            <span>D20: 0</span>
            <button class="add">+</button>
        </div>
    </div>
    <div id="canvas-container"></div>
    <button id="roll-button">Roll Dice</button>
    <div id="results">
        <h3>Roll Results</h3>
        <ul id="roll-log"></ul>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Debug flag - set to true for console logging
        const DEBUG = true;
        
        // Wait for DOM and external resources to load
        window.addEventListener('load', function() {
            if (DEBUG) console.log("Page loaded, initializing...");
            
            if (typeof THREE === 'undefined') {
                console.error('Three.js failed to load. Check your internet connection or the CDN link.');
                
                // Display a user-friendly error
                const container = document.getElementById('canvas-container');
                container.innerHTML = '<div style="color: white; text-align: center; padding: 20px;">Failed to load 3D graphics library. Please check your internet connection and reload the page.</div>';
                return;
            }
            
            if (DEBUG) console.log("Three.js loaded successfully");
            
            initDiceRoller();
        });
        
        function initDiceRoller() {
            // Basic scene setup
            const container = document.getElementById('canvas-container');
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Black background
            
            const camera = new THREE.PerspectiveCamera(
                75, // Field of view
                container.clientWidth / container.clientHeight, // Aspect ratio
                0.1, // Near clipping plane
                100 // Far clipping plane
            );
            
            // Position the camera
            camera.position.set(0, 3, 10);
            camera.lookAt(0, 0, 0);
            
            if (DEBUG) console.log("Camera set up:", camera.position);
            
            // Create renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            if (DEBUG) console.log("Renderer created and added to container");
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);
            
            if (DEBUG) console.log("Lighting added to scene");
            
            // Add a simple dark floor
            const floorGeometry = new THREE.PlaneGeometry(30, 30);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            floor.position.y = -2; // Slightly below origin
            scene.add(floor);
            
            if (DEBUG) console.log("Floor added to scene");
            
            // Add simple starfield
            addSimpleStarfield(scene);
            
            // Dice management
            const diceTypes = ['d4', 'd6', 'd8', 'd10', 'd12', 'd20'];
            const diceCounts = { d4: 0, d6: 0, d8: 0, d10: 0, d12: 0, d20: 0 };
            const dice = [];
            
            if (DEBUG) console.log("Dice arrays initialized");
            
            // Dice colors
            const diceColors = {
                d4: 0xff0000,    // Red
                d6: 0x00ff00,    // Green
                d8: 0x0000ff,    // Blue
                d10: 0xff00ff,   // Purple
                d12: 0xffff00,   // Yellow
                d20: 0x00ffff    // Cyan
            };
            
            // Create simple geometries for each die type
            const geometries = {
                d4: new THREE.TetrahedronGeometry(1),
                d6: new THREE.BoxGeometry(1.5, 1.5, 1.5),
                d8: new THREE.OctahedronGeometry(1.2),
                d10: new THREE.ConeGeometry(1, 2, 10),
                d12: new THREE.DodecahedronGeometry(1.2),
                d20: new THREE.IcosahedronGeometry(1.2)
            };
            
            if (DEBUG) console.log("Die geometries created");
            
            // Simple die creation function
            function createDie(type) {
                if (DEBUG) console.log(`Creating die of type ${type}`);
                
                const geometry = geometries[type];
                const color = diceColors[type];
                
                // Create material with some shine
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    metalness: 0.3,
                    roughness: 0.4
                });
                
                // Create the die mesh
                const die = new THREE.Mesh(geometry, material);
                
                // Add edge highlighting
                const edges = new THREE.EdgesGeometry(geometry);
                const edgeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
                const wireframe = new THREE.LineSegments(edges, edgeMaterial);
                die.add(wireframe);
                
                // Set initial position slightly above the floor
                die.position.y = 0;
                
                // Store die properties
                die.userData = {
                    type: type,
                    result: 0,
                    isRolling: false,
                    velocity: new THREE.Vector3(0, 0, 0),
                    angularVelocity: new THREE.Vector3(0, 0, 0)
                };
                
                if (DEBUG) console.log(`Die of type ${type} created successfully`);
                return die;
            }
            
            // Add die to scene
            function addDie(type) {
                try {
                    if (diceCounts[type] >= 10) return; // Maximum 10 dice per type
                    
                    const die = createDie(type);
                    scene.add(die);
                    dice.push(die);
                    diceCounts[type]++;
                    
                    // Position dice in a grid or circle
                    positionDice();
                    
                    // Update counter display
                    updateControls();
                    
                    if (DEBUG) console.log(`Added die type ${type}, new count: ${diceCounts[type]}`);
                    return die;
                } catch (error) {
                    console.error(`Error adding die type ${type}:`, error);
                }
            }
            
            // Remove die from scene
            function removeDie(type) {
                if (diceCounts[type] <= 0) return;
                
                // Find a die of the specified type
                const index = dice.findIndex(die => die.userData.type === type);
                if (index === -1) return;
                
                // Remove the die
                scene.remove(dice[index]);
                dice.splice(index, 1);
                diceCounts[type]--;
                
                // Reposition remaining dice
                positionDice();
                
                // Update counter display
                updateControls();
                
                if (DEBUG) console.log(`Removed die type ${type}, new count: ${diceCounts[type]}`);
            }
            
            // Position dice in scene
            function positionDice() {
                const count = dice.length;
                if (count === 0) return;
                
                // Arrange in a grid
                const spacing = 2.0;
                const rowSize = Math.ceil(Math.sqrt(count));
                const startX = -((rowSize - 1) * spacing) / 2;
                const startZ = -((rowSize - 1) * spacing) / 2;
                
                dice.forEach((die, index) => {
                    const row = Math.floor(index / rowSize);
                    const col = index % rowSize;
                    
                    die.position.x = startX + col * spacing;
                    die.position.z = startZ + row * spacing;
                    die.position.y = 0.5; // Slightly above the floor
                    
                    // Random rotation
                    die.rotation.set(
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2
                    );
                });
                
                if (DEBUG) console.log(`Repositioned ${count} dice in scene`);
            }
            
            // Update control displays
            function updateControls() {
                diceTypes.forEach(type => {
                    const control = document.querySelector(`.dice-control[data-type="${type}"] span`);
                    if (control) {
                        control.textContent = `${type.toUpperCase()}: ${diceCounts[type]}`;
                    }
                });
            }
            
            // Roll physics
            function rollDice() {
                if (dice.length === 0) return;
                
                const rollButton = document.getElementById('roll-button');
                rollButton.disabled = true;
                rollButton.textContent = "Rolling...";
                
                // Generate random results for each die
                dice.forEach(die => {
                    const type = die.userData.type;
                    const faces = parseInt(type.slice(1));
                    die.userData.result = Math.floor(Math.random() * faces) + 1;
                    die.userData.isRolling = true;
                    
                    // Set initial throw velocity and position
                    die.position.y = 3 + Math.random() * 2;
                    die.userData.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 5,
                        Math.random() * 5 + 5,
                        (Math.random() - 0.5) * 5
                    );
                    
                    die.userData.angularVelocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10
                    );
                });
                
                // Roll for 2 seconds then display results
                setTimeout(() => {
                    dice.forEach(die => {
                        die.userData.isRolling = false;
                    });
                    displayResults();
                    rollButton.disabled = false;
                    rollButton.textContent = "Roll Dice";
                }, 2000);
            }
            
            // Update dice physics during rolling
            function updateDicePhysics(delta) {
                const gravity = new THREE.Vector3(0, -9.8, 0);
                const floorY = -0.5;
                
                dice.forEach(die => {
                    if (!die.userData.isRolling) return;
                    
                    // Update position with velocity
                    die.position.addScaledVector(die.userData.velocity, delta);
                    
                    // Update rotation with angular velocity
                    die.rotation.x += die.userData.angularVelocity.x * delta;
                    die.rotation.y += die.userData.angularVelocity.y * delta;
                    die.rotation.z += die.userData.angularVelocity.z * delta;
                    
                    // Apply gravity
                    die.userData.velocity.addScaledVector(gravity, delta);
                    
                    // Air resistance
                    die.userData.velocity.multiplyScalar(0.98);
                    die.userData.angularVelocity.multiplyScalar(0.98);
                    
                    // Floor collision
                    const dieSize = 0.75; // Approximate die radius
                    if (die.position.y - dieSize < floorY) {
                        die.position.y = floorY + dieSize;
                        die.userData.velocity.y *= -0.7; // Bounce with energy loss
                        
                        // Lateral friction on floor
                        die.userData.velocity.x *= 0.9;
                        die.userData.velocity.z *= 0.9;
                    }
                    
                    // Wall collisions to keep dice in view
                    const bounds = 10;
                    if (Math.abs(die.position.x) > bounds) {
                        die.position.x = Math.sign(die.position.x) * bounds;
                        die.userData.velocity.x *= -0.7;
                    }
                    if (Math.abs(die.position.z) > bounds) {
                        die.position.z = Math.sign(die.position.z) * bounds;
                        die.userData.velocity.z *= -0.7;
                    }
                });
            }
            
            // Display roll results
            function displayResults() {
                const rollLog = document.getElementById('roll-log');
                
                // Group results by die type
                const resultsByType = {};
                let totalSum = 0;
                
                dice.forEach(die => {
                    const type = die.userData.type;
                    const result = die.userData.result;
                    
                    if (!resultsByType[type]) {
                        resultsByType[type] = [];
                    }
                    
                    resultsByType[type].push(result);
                    totalSum += result;
                });
                
                // Create formatted results HTML
                let resultHTML = '';
                
                for (const type in resultsByType) {
                    if (resultsByType[type].length > 0) {
                        resultHTML += `<span class="${type}-result">${type.toUpperCase()}: [${resultsByType[type].join(', ')}]</span> `;
                    }
                }
                
                resultHTML += `<span class="total-result">Total: ${totalSum}</span>`;
                
                // Add to log
                const logEntry = document.createElement('li');
                logEntry.innerHTML = resultHTML;
                rollLog.insertBefore(logEntry, rollLog.firstChild);
                
                // Keep only last 8 rolls
                while (rollLog.children.length > 8) {
                    rollLog.removeChild(rollLog.lastChild);
                }
            }
            
            // Simple star field
            function addSimpleStarfield(scene) {
                const starCount = 1000;
                const starGeometry = new THREE.BufferGeometry();
                const starPositions = new Float32Array(starCount * 3);
                
                for (let i = 0; i < starCount * 3; i += 3) {
                    // Position stars in a large sphere
                    const r = 50;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    starPositions[i] = r * Math.sin(phi) * Math.cos(theta);
                    starPositions[i+1] = r * Math.sin(phi) * Math.sin(theta);
                    starPositions[i+2] = r * Math.cos(phi);
                }
                
                starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
                
                const starMaterial = new THREE.PointsMaterial({
                    size: 0.5,
                    color: 0xffffff
                });
                
                const starField = new THREE.Points(starGeometry, starMaterial);
                scene.add(starField);
                
                if (DEBUG) console.log("Starfield added to scene");
            }
            
            // Animation loop
            let lastTime = 0;
            
            function animate(time) {
                requestAnimationFrame(animate);
                
                // Calculate delta time for physics
                const delta = Math.min((time - lastTime) / 1000, 0.1); // Cap at 0.1 seconds
                lastTime = time;
                
                // Update physics
                updateDicePhysics(delta);
                
                // Render
                renderer.render(scene, camera);
            }
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
            
            // Add control listeners
            document.querySelectorAll('.dice-control .add').forEach(button => {
                button.addEventListener('click', function() {
                    const type = this.parentElement.dataset.type;
                    addDie(type);
                });
            });
            
            document.querySelectorAll('.dice-control .remove').forEach(button => {
                button.addEventListener('click', function() {
                    const type = this.parentElement.dataset.type;
                    removeDie(type);
                });
            });
            
            // Roll button
            document.getElementById('roll-button').addEventListener('click', rollDice);
            
            // Initialize with some dice
            function addStarterDice() {
                if (DEBUG) console.log("Adding starter dice");
                
                // Add one of each type of die
                diceTypes.forEach(type => {
                    addDie(type);
                });
            }
            
            // Start animation
            animate(0);
            
            // Add starter dice after a short delay
            setTimeout(addStarterDice, 100);
            
            if (DEBUG) console.log("Dice roller initialization complete");
        }
    </script>

            // Scene setup - modified for better view
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Pure black background
            
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth * 0.9 / (window.innerHeight * 0.5), 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            const container = document.getElementById('canvas-container');
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            const pointLight2 = new THREE.PointLight(0xffffff, 0.5);
            pointLight2.position.set(-10, -5, 8);
            scene.add(pointLight2);

            // Camera position - closer to see dice better
            camera.position.z = 7;
            camera.position.y = 2;

            // Add a space-themed environment with stars
            function createStarfield() {
                // Create starfield points
                const starCount = 3000;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(starCount * 3);
                const sizes = new Float32Array(starCount);
                const colors = new Float32Array(starCount * 3);
                
                for (let i = 0; i < starCount; i++) {
                    // Position stars in a large sphere around the scene
                    const radius = 40 + Math.random() * 10;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                    
                    // Random star sizes
                    sizes[i] = Math.random() * 2 + 0.5;
                    
                    // Random star colors (mostly white with some color variation)
                    const starColor = Math.random();
                    if (starColor > 0.9) {
                        // Bluish stars
                        colors[i * 3] = 0.7 + Math.random() * 0.3;
                        colors[i * 3 + 1] = 0.7 + Math.random() * 0.3;
                        colors[i * 3 + 2] = 1.0;
                    } else if (starColor > 0.8) {
                        // Reddish stars
                        colors[i * 3] = 1.0;
                        colors[i * 3 + 1] = 0.7 + Math.random() * 0.3;
                        colors[i * 3 + 2] = 0.7 + Math.random() * 0.3;
                    } else {
                        // White stars
                        colors[i * 3] = 1.0;
                        colors[i * 3 + 1] = 1.0;
                        colors[i * 3 + 2] = 1.0;
                    }
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const starsMaterial = new THREE.PointsMaterial({
                    size: 0.8,
                    sizeAttenuation: true,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8
                });
                
                const stars = new THREE.Points(geometry, starsMaterial);
                scene.add(stars);
                
                // Add a few bright "hero" stars
                const bigStarCount = 50;
                const bigStarGeometry = new THREE.BufferGeometry();
                const bigStarPositions = new Float32Array(bigStarCount * 3);
                const bigStarSizes = new Float32Array(bigStarCount);
                
                for (let i = 0; i < bigStarCount; i++) {
                    const radius = 38 + Math.random() * 10;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    bigStarPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    bigStarPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    bigStarPositions[i * 3 + 2] = radius * Math.cos(phi);
                    
                    bigStarSizes[i] = Math.random() * 3 + 2;
                }
                
                bigStarGeometry.setAttribute('position', new THREE.BufferAttribute(bigStarPositions, 3));
                bigStarGeometry.setAttribute('size', new THREE.BufferAttribute(bigStarSizes, 1));
                
                const bigStarsMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 2,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.9
                });
                
                const bigStars = new THREE.Points(bigStarGeometry, bigStarsMaterial);
                scene.add(bigStars);
            }
            
            // Create starfield
            createStarfield();

            // Add a black table surface
            const tableGeometry = new THREE.PlaneGeometry(30, 30);
            const tableMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000, 
                roughness: 0.9,  // Very high roughness (less reflective)
                metalness: 0.0   // No metallic quality
            });
            const table = new THREE.Mesh(tableGeometry, tableMaterial);
            table.rotation.x = -Math.PI / 2;
            table.position.y = 0;
            scene.add(table);
            
            // Add subtle edge glow to the table
            const tableEdgeGeometry = new THREE.RingGeometry(14.8, 15, 64);
            const tableEdgeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x0066ff, 
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const tableEdge = new THREE.Mesh(tableEdgeGeometry, tableEdgeMaterial);
            tableEdge.rotation.x = -Math.PI / 2;
            tableEdge.position.y = 0.01;
            scene.add(tableEdge);

            // Initialize dice management
            const diceTypes = ['d4', 'd6', 'd8', 'd10', 'd12', 'd20'];
            const diceCounts = { d4: 0, d6: 0, d8: 0, d10: 0, d12: 0, d20: 0 };
            const dice = [];

            // Face configurations for proper orientation
            // This defines which face should point up for each result
            const faceConfigurations = {
                d4: [
                    { result: 1, up: new THREE.Vector3(0, 1, 0), rotation: new THREE.Euler(0, 0, 0) },
                    { result: 2, up: new THREE.Vector3(1, 0, 0), rotation: new THREE.Euler(0, 0, Math.PI/2) },
                    { result: 3, up: new THREE.Vector3(0, 0, 1), rotation: new THREE.Euler(Math.PI/2, 0, 0) },
                    { result: 4, up: new THREE.Vector3(-1, -1, -1).normalize(), rotation: new THREE.Euler(Math.PI, 0, 0) }
                ],
                d6: [
                    { result: 1, up: new THREE.Vector3(0, 1, 0), rotation: new THREE.Euler(0, 0, 0) },
                    { result: 2, up: new THREE.Vector3(1, 0, 0), rotation: new THREE.Euler(0, 0, Math.PI/2) },
                    { result: 3, up: new THREE.Vector3(0, 0, 1), rotation: new THREE.Euler(Math.PI/2, 0, 0) },
                    { result: 4, up: new THREE.Vector3(0, 0, -1), rotation: new THREE.Euler(-Math.PI/2, 0, 0) },
                    { result: 5, up: new THREE.Vector3(-1, 0, 0), rotation: new THREE.Euler(0, 0, -Math.PI/2) },
                    { result: 6, up: new THREE.Vector3(0, -1, 0), rotation: new THREE.Euler(Math.PI, 0, 0) }
                ],
                d8: Array.from({ length: 8 }, (_, i) => ({ 
                    result: i + 1, 
                    up: new THREE.Vector3(
                        i % 2 === 0 ? 1 : -1, 
                        i % 4 < 2 ? 1 : -1, 
                        i < 4 ? 1 : -1
                    ).normalize(),
                    rotation: new THREE.Euler(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI)
                })),
                d10: Array.from({ length: 10 }, (_, i) => ({ 
                    result: i + 1, 
                    up: new THREE.Vector3(
                        Math.cos(i * Math.PI/5) * Math.sin(Math.PI/3),
                        Math.cos(Math.PI/3),
                        Math.sin(i * Math.PI/5) * Math.sin(Math.PI/3)
                    ),
                    rotation: new THREE.Euler(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI)
                })),
                d12: Array.from({ length: 12 }, (_, i) => ({ 
                    result: i + 1, 
                    up: new THREE.Vector3(
                        Math.cos(i * Math.PI/6) * Math.sin(Math.PI/5),
                        Math.cos(Math.PI/5),
                        Math.sin(i * Math.PI/6) * Math.sin(Math.PI/5)
                    ),
                    rotation: new THREE.Euler(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI)
                })),
                d20: Array.from({ length: 20 }, (_, i) => ({ 
                    result: i + 1, 
                    up: new THREE.Vector3(
                        Math.cos(i * Math.PI/10) * Math.sin(Math.PI/4),
                        Math.cos(Math.PI/4),
                        Math.sin(i * Math.PI/10) * Math.sin(Math.PI/4)
                    ),
                    rotation: new THREE.Euler(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI)
                }))
            };

            // Geometries for each dice type
            const geometries = {
                d4: new THREE.TetrahedronGeometry(1),
                d6: new THREE.BoxGeometry(1, 1, 1),
                d8: new THREE.OctahedronGeometry(1),
                d10: new THREE.ConeGeometry(0.8, 1.2, 10), // Better approximation for D10
                d12: new THREE.DodecahedronGeometry(1),
                d20: new THREE.IcosahedronGeometry(1)
            };

            // Create number texture for dice faces
            function createNumberTexture(number, color) {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                
                // Clear background with slight transparency
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(0, 0, 128, 128);
                
                // Draw number
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 80px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(number.toString(), 64, 64);
                
                // Add subtle border
                ctx.strokeStyle = color;
                ctx.lineWidth = 4;
                ctx.strokeRect(5, 5, 118, 118);
                
                return new THREE.CanvasTexture(canvas);
            }

            // Create a die with solid colors and glossy appearance (no numbers)
            function createDie(type) {
                const geometry = geometries[type];
                const diceColor = diceColors[type];
                
                // Create more vibrant glossy material
                const material = new THREE.MeshStandardMaterial({ 
                    color: diceColor,
                    metalness: 0.5,
                    roughness: 0.1,
                    envMapIntensity: 1.5,
                    flatShading: false
                });
                
                // Add edge highlighting with a second material
                const edges = new THREE.EdgesGeometry(geometry);
                const edgeMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffffff,
                    linewidth: 1
                });
                const wireframe = new THREE.LineSegments(edges, edgeMaterial);
                
                // Create the main die
                const die = new THREE.Mesh(geometry, material);
                die.add(wireframe);
                
                // Get number of faces from dice type
                const faces = parseInt(type.slice(1));
                
                // Store physics properties
                die.userData = {
                    type: type,
                    rollingSpeed: new THREE.Vector3(0, 0, 0),
                    angularVelocity: new THREE.Vector3(0, 0, 0),
                    isRolling: false,
                    rollResult: 0,
                    faces: faces
                };
                
                return die;
            }

                // Store physics properties
                die.userData = {
                    type: type,
                    rollingSpeed: new THREE.Vector3(0, 0, 0),
                    angularVelocity: new THREE.Vector3(0, 0, 0),
                    isRolling: false,
                    rollResult: 0,
                    faces: faces
                };
                
                return die;
            }

            // Add a die to the scene - fixed implementation
            function addDie(type) {
                if (diceCounts[type] < 10) {
                    diceCounts[type]++;
                    try {
                        const die = createDie(type);
                        dice.push(die);
                        scene.add(die);
                        console.log(`Added ${type} die. Total: ${diceCounts[type]}`);
                        positionDice();
                        updateControls();
                    } catch (error) {
                        console.error(`Error adding ${type} die:`, error);
                        diceCounts[type]--; // Revert the count increase
                    }
                }
            }

            // Remove a die from the scene - fixed implementation
            function removeDie(type) {
                if (diceCounts[type] > 0) {
                    diceCounts[type]--;
                    try {
                        // Find dice of the specified type
                        const index = dice.findIndex(d => d.userData.type === type);
                        if (index !== -1) {
                            scene.remove(dice[index]);
                            dice.splice(index, 1);
                            console.log(`Removed ${type} die. Remaining: ${diceCounts[type]}`);
                            positionDice();
                            updateControls();
                        }
                    } catch (error) {
                        console.error(`Error removing ${type} die:`, error);
                        diceCounts[type]++; // Revert the count decrease
                    }
                }
            }

            // Position dice in the scene - closer spacing and better initial position
            function positionDice() {
                const totalDice = dice.length;
                if (totalDice === 0) return;
                
                // Arrange in a more compact grid
                if (totalDice <= 25) {
                    const gridSize = Math.ceil(Math.sqrt(totalDice));
                    const spacing = 1.8; // Closer spacing
                    const offset = (gridSize - 1) * spacing / 2;
                    
                    dice.forEach((die, index) => {
                        const row = Math.floor(index / gridSize);
                        const col = index % gridSize;
                        die.position.set(
                            col * spacing - offset,
                            0.5, // Slightly elevated for better visibility
                            row * spacing - offset
                        );
                        
                        // Random initial orientation
                        die.rotation.set(
                            Math.random() * Math.PI * 2,
                            Math.random() * Math.PI * 2,
                            Math.random() * Math.PI * 2
                        );
                        
                        // Add slight scale variation for visual interest
                        const scale = 0.85 + Math.random() * 0.3;
                        die.scale.set(scale, scale, scale);
                    });
                } else {
                    // Fallback to circular arrangement for many dice
                    const radius = Math.min(totalDice * 0.3, 4);
                    dice.forEach((die, index) => {
                        const angle = (index / totalDice) * Math.PI * 2;
                        die.position.set(
                            Math.cos(angle) * radius,
                            0.5,
                            Math.sin(angle) * radius
                        );
                    });
                }
            }
                if (totalDice === 0) return;
                
                // Arrange in a more compact grid
                if (totalDice <= 25) {
                    const gridSize = Math.ceil(Math.sqrt(totalDice));
                    const spacing = 1.8; // Closer spacing
                    const offset = (gridSize - 1) * spacing / 2;
                    
                    dice.forEach((die, index) => {
                        const row = Math.floor(index / gridSize);
                        const col = index % gridSize;
                        die.position.set(
                            col * spacing - offset,
                            0.5, // Slightly elevated for better visibility
                            row * spacing - offset
                        );
                        
                        // Random initial orientation
                        die.rotation.set(
                            Math.random() * Math.PI * 2,
                            Math.random() * Math.PI * 2,
                            Math.random() * Math.PI * 2
                        );
                        
                        // Add slight scale variation for visual interest
                        const scale = 0.85 + Math.random() * 0.3;
                        die.scale.set(scale, scale, scale);
                    });
                } else {
                    // Fallback to circular arrangement for many dice
                    const radius = Math.min(totalDice * 0.3, 4);
                    dice.forEach((die, index) => {
                        const angle = (index / totalDice) * Math.PI * 2;
                        die.position.set(
                            Math.cos(angle) * radius,
                            0.5,
                            Math.sin(angle) * radius
                        );
                    });
                }
            }

            // Update control displays with error handling
            function updateControls() {
                try {
                    diceTypes.forEach(type => {
                        const control = document.querySelector(`.dice-control[data-type="${type}"] span`);
                        if (control) {
                            control.textContent = `${type.toUpperCase()}: ${diceCounts[type]}`;
                        }
                    });
                } catch (error) {
                    console.error("Error updating controls:", error);
                }
            }

            // Generate a random roll result
            function rollDie(type) {
                return Math.floor(Math.random() * parseInt(type.slice(1))) + 1;
            }

            // Set the die orientation based on the roll result
            function setDieOrientation(die, result) {
                const type = die.userData.type;
                const faceConfig = faceConfigurations[type].find(f => f.result === result);
                
                if (faceConfig) {
                    // Create a matrix to orient the die with the correct face up
                    const targetQuaternion = new THREE.Quaternion().setFromEuler(faceConfig.rotation);
                    die.quaternion.copy(targetQuaternion);
                    
                    // Add a slight random rotation around the up axis for variety
                    const randomAngle = Math.random() * Math.PI * 2;
                    const extraRotation = new THREE.Quaternion().setFromAxisAngle(faceConfig.up, randomAngle);
                    die.quaternion.multiply(extraRotation);
                    
                    // Store the result
                    die.userData.rollResult = result;
                }
            }

            // Much more forceful roll animation with harder throws
            function rollDice() {
                if (dice.length === 0) return;
                
                const rollButton = document.getElementById('roll-button');
                rollButton.disabled = true;
                rollButton.textContent = "Rolling...";
                
                // Generate roll results before animation
                const results = dice.map(die => {
                    const result = rollDie(die.userData.type);
                    die.userData.rollResult = result;
                    return result;
                });
                
                // Set initial physics for much more forceful roll
                dice.forEach(die => {
                    die.userData.isRolling = true;
                    die.userData.rollTime = 0;
                    
                    // MUCH more forceful initial velocity
                    die.userData.rollingSpeed = new THREE.Vector3(
                        (Math.random() - 0.5) * 5.0, // Much stronger horizontal force
                        Math.random() * 2.0 + 1.5,   // Higher initial toss
                        (Math.random() - 0.5) * 5.0  // Much stronger horizontal force
                    );
                    
                    // Much more energetic angular velocity for dramatic spins
                    die.userData.angularVelocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 12.0, // Very fast rotation
                        (Math.random() - 0.5) * 12.0,
                        (Math.random() - 0.5) * 12.0
                    );
                    
                    // Higher initial position for more dramatic drops
                    die.position.y = 4 + Math.random() * 2;
                    
                    // Reset scale to normal
                    die.scale.set(1, 1, 1);
                });
                
                // Roll duration - longer for more dramatic animation
                const rollDuration = 2500; // milliseconds
                
                // After animation completes, set the final orientation for the result
                setTimeout(() => {
                    dice.forEach(die => {
                        const result = die.userData.rollResult;
                        setDieOrientation(die, result);
                        die.userData.isRolling = false;
                        
                        // Make the final position on the table
                        die.position.y = 0.5;
                    });
                    
                    displayResults();
                    rollButton.disabled = false;
                    rollButton.textContent = "Roll Dice";
                }, rollDuration);
            }

            // Display roll results and log
            function displayResults() {
                const rollLog = document.getElementById('roll-log');
                let resultHTML = '';
                
                // Group results by dice type
                const resultsByType = {};
                let totalSum = 0;
                
                dice.forEach(die => {
                    const type = die.userData.type;
                    const result = die.userData.rollResult;
                    
                    if (!resultsByType[type]) {
                        resultsByType[type] = [];
                    }
                    
                    resultsByType[type].push(result);
                    totalSum += result;
                });
                
                // Create formatted results
                for (const type in resultsByType) {
                    if (resultsByType[type].length > 0) {
                        resultHTML += `<span class="${type}-result">${type.toUpperCase()}: [${resultsByType[type].join(', ')}]</span> `;
                    }
                }
                
                // Add total
                resultHTML += `<span class="total-result">Total: ${totalSum}</span>`;
                
                // Create log entry
                const logEntry = document.createElement('li');
                logEntry.innerHTML = resultHTML;
                rollLog.insertBefore(logEntry, rollLog.firstChild);
                
                // Keep only the last 8 rolls
                while (rollLog.children.length > 8) {
                    rollLog.removeChild(rollLog.lastChild);
                }
            }

            // Enhanced physics update for more energetic and longer rolling
            function updateDicePhysics(delta) {
                const gravity = new THREE.Vector3(0, -12.0, 0); // Stronger gravity
                const airResistance = 0.98; // Lower air resistance for longer rolls
                const tableY = 0; // Height of the table surface
                
                dice.forEach(die => {
                    if (die.userData.isRolling) {
                        // Update position based on velocity
                        die.position.add(die.userData.rollingSpeed.clone().multiplyScalar(delta));
                        
                        // Update rotation based on angular velocity
                        die.rotation.x += die.userData.angularVelocity.x * delta;
                        die.rotation.y += die.userData.angularVelocity.y * delta;
                        die.rotation.z += die.userData.angularVelocity.z * delta;
                        
                        // Apply gravity to velocity
                        die.userData.rollingSpeed.add(gravity.clone().multiplyScalar(delta));
                        
                        // Apply air resistance
                        die.userData.rollingSpeed.multiplyScalar(airResistance);
                        die.userData.angularVelocity.multiplyScalar(airResistance);
                        
                        // Handle collision with table - more energetic bounces
                        if (die.position.y - 0.5 < tableY) {
                            die.position.y = tableY + 0.5;
                            
                            // More energetic bounce - conserve more energy
                            die.userData.rollingSpeed.y = Math.abs(die.userData.rollingSpeed.y) * 0.8;
                            
                            // Add a minimum bounce height for visual interest
                            if (die.userData.rollingSpeed.y < 0.8 && die.userData.rollingSpeed.y > 0.1) {
                                die.userData.rollingSpeed.y = 0.8;
                            }
                            
                            // More dramatic rotation on bounce
                            const bounceRotation = Math.random() * 1.2 + 0.5;
                            die.userData.angularVelocity.x += (Math.random() - 0.5) * bounceRotation;
                            die.userData.angularVelocity.z += (Math.random() - 0.5) * bounceRotation;
                            
                            // Less friction with table for longer, more dynamic rolls
                            die.userData.rollingSpeed.x *= 0.95;
                            die.userData.rollingSpeed.z *= 0.95;
                        }
                        
                        // Boundary checks with more elastic collisions for dramatic bounces
                        const boundary = 12; // Larger boundary
                        if (Math.abs(die.position.x) > boundary) {
                            die.position.x = Math.sign(die.position.x) * boundary;
                            die.userData.rollingSpeed.x *= -0.9; // More elastic wall bounce
                            
                            // Add some random vertical bounce off walls
                            die.userData.rollingSpeed.y += Math.random() * 1.0;
                            
                            // Add some random spin when hitting walls
                            die.userData.angularVelocity.y += (Math.random() - 0.5) * 2.0;
                            die.userData.angularVelocity.z += (Math.random() - 0.5) * 2.0;
                        }
                        if (Math.abs(die.position.z) > boundary) {
                            die.position.z = Math.sign(die.position.z) * boundary;
                            die.userData.rollingSpeed.z *= -0.9; // More elastic wall bounce
                            
                            // Add some random vertical bounce off walls
                            die.userData.rollingSpeed.y += Math.random() * 1.0;
                            
                            // Add some random spin when hitting walls
                            die.userData.angularVelocity.x += (Math.random() - 0.5) * 2.0;
                            die.userData.angularVelocity.y += (Math.random() - 0.5) * 2.0;
                        }
                    }
                });
            }

            // Add control button listeners - fixed implementation
            document.querySelectorAll('.dice-control .add').forEach(button => {
                button.addEventListener('click', function() {
                    const type = this.parentElement.dataset.type;
                    addDie(type);
                });
            });
            
            document.querySelectorAll('.dice-control .remove').forEach(button => {
                button.addEventListener('click', function() {
                    const type = this.parentElement.dataset.type;
                    removeDie(type);
                });
            });

            // Roll button logic
            document.getElementById('roll-button').addEventListener('click', rollDice);

            // Animation setup with error handling
            let lastTime = 0;
            
            // Animation loop
            function animate(time) {
                try {
                    requestAnimationFrame(animate);
                    
                    // Calculate delta time for physics
                    const delta = (time - lastTime) / 1000; // Convert to seconds
                    lastTime = time;
                    
                    // Update physics
                    if (delta < 0.2) { // Skip extreme deltas (e.g., after tab becomes active again)
                        updateDicePhysics(delta);
                    }
                    
                    // Render the scene
                    renderer.render(scene, camera);
                } catch (error) {
                    console.error("Animation error:", error);
                }
            }
            
            // Start animation with error handling
            try {
                animate(0);
            } catch (error) {
                console.error("Failed to start animation:", error);
            }

            // Handle window resize - improved to maintain aspect ratio correctly
            window.addEventListener('resize', () => {
                const width = container.clientWidth;
                const height = container.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            });
            
            // Dice colors with great contrast against black background
            const diceColors = {
                d4: 0xff5555,   // Bright Red
                d6: 0x55ff55,   // Bright Green
                d8: 0x5555ff,   // Bright Blue
                d10: 0xff55ff,  // Bright Purple
                d12: 0xffff44,  // Bright Yellow
                d20: 0x55ffff   // Bright Cyan
            };
        });
    </script>
</body>
</html>
