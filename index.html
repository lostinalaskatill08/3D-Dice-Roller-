<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D D&D Dice Roller</title>
  <link rel="icon" href="data:,">
  <style>
    body {
      margin: 0;
      background-color: #1a1a1a;
      color: #fff;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      /* Removed height: 100vh and overflow: hidden so the page can scroll. */
    }
    #controls {
      margin: 20px 0;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
    }
    .dice-control {
      background-color: #ff4444;
      padding: 10px;
      margin: 5px;
      border-radius: 5px;
      display: flex;
      align-items: center;
    }
    .dice-control span {
      margin: 0 10px;
      color: yellow;
      font-weight: bold;
    }
    .dice-control button {
      background-color: yellow;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      font-weight: bold;
      border-radius: 3px;
    }
    .dice-control button:hover {
      background-color: #e6e600;
    }
    /* Give a fixed height (e.g. 400px) so the dice area is clearly visible. */
    #canvas-container {
      width: 80%;
      height: 400px;
      border: 2px solid #ff4444;
      background-color: #000;
      position: relative;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(255,255,255,0.1);
      margin-bottom: 10px;
    }
    #roll-button {
      margin: 10px 0;
      padding: 10px 20px;
      background-color: #4444ff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
    }
    #roll-button:hover {
      background-color: #3333cc;
    }
    /* Increased max-height for the roll log to make it more readable. */
    #results {
      background-color: #222;
      padding: 10px;
      border: 1px solid yellow;
      border-radius: 5px;
      width: 80%;
      max-height: 300px; /* Adjust as desired */
      overflow-y: auto;
      color: #fff;
      margin-bottom: 10px;
    }
    #results-header {
      color: yellow;
      margin: 0 0 5px 0;
      padding: 5px 0;
      font-size: 16px;
      font-weight: bold;
      text-align: center;
      width: 80%;
    }
    #roll-log {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    #roll-log li {
      padding: 8px;
      margin-bottom: 5px;
      background-color: #333;
      border-radius: 4px;
    }
    #roll-log li:nth-child(odd) {
      background-color: #2a2a2a;
    }
    .die-result {
      display: inline-block;
      padding: 3px 6px;
      margin: 0 3px;
      border-radius: 3px;
      font-weight: bold;
    }
    /* Dice result backgrounds matching dice colors */
    .d4-result    { background-color: rgba(139, 0, 0, 0.5); }
    .d6-result    { background-color: rgba(105, 105, 105, 0.5); }
    .d8-result    { background-color: rgba(47, 79, 79, 0.5); }
    .d10-result   { background-color: rgba(85, 107, 47, 0.5); }
    .d12-result   { background-color: rgba(184, 134, 11, 0.5); }
    .d20-result   { background-color: rgba(72, 61, 139, 0.5); }
    .total-result {
      background-color: #ff9900;
      color: white;
      padding: 3px 8px;
      border-radius: 4px;
      margin-left: 8px;
    }
    /* Dice Usage Information section */
    #dice-info {
      background-color: #222;
      color: #fff;
      border: 1px solid yellow;
      border-radius: 5px;
      width: 80%;
      padding: 10px;
      margin-top: 10px;
      max-height: 300px; /* You can also adjust this if you want more/less space. */
      overflow-y: auto;
    }
    #dice-info h2, #dice-info h3 {
      color: yellow;
      text-align: center;
      margin: 10px 0 5px;
    }
    #dice-info p {
      margin: 5px 0;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <div class="dice-control" data-type="d4">
      <button class="remove">-</button>
      <span>D4: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d6">
      <button class="remove">-</button>
      <span>D6: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d8">
      <button class="remove">-</button>
      <span>D8: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d10">
      <button class="remove">-</button>
      <span>D10: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d12">
      <button class="remove">-</button>
      <span>D12: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d20">
      <button class="remove">-</button>
      <span>D20: 0</span>
      <button class="add">+</button>
    </div>
  </div>

  <div id="canvas-container"></div>

  <button id="roll-button">Roll Dice</button>

  <div id="results-header">Roll Results</div>
  <div id="results">
    <ul id="roll-log"></ul>
  </div>

  <!-- Dice Usage Information -->
  <div id="dice-info">
    <h2>Dice Usage Information</h2>
    <div class="dice-section">
      <h3>D4 (4-sided die)</h3>
      <p><strong>Damage:</strong> Used for low-damage rolls (e.g. daggers, minor spells) and small healing effects.</p>
      <p><strong>Bonus:</strong> Sometimes adds a small bonus to d20 rolls (e.g. Bless, Guidance).</p>
    </div>
    <div class="dice-section">
      <h3>D6 (6-sided die)</h3>
      <p><strong>Damage:</strong> Frequently rolled for weapon damage (shortswords, handaxes) and big spells (Fireball with multiple d6s).</p>
      <p><strong>Ability Scores:</strong> Commonly used for 4d6 drop-lowest ability score generation.</p>
      <p><strong>Hit Dice:</strong> Wizards/Sorcerers use a d6 for HP growth.</p>
    </div>
    <div class="dice-section">
      <h3>D8 (8-sided die)</h3>
      <p><strong>Damage:</strong> Standard for one-handed martial weapons (longswords, rapiers) and many spells.</p>
      <p><strong>Hit Dice:</strong> Mid-tier classes (Cleric, Druid, Rogue, Bard, Monk).</p>
    </div>
    <div class="dice-section">
      <h3>D10 (10-sided die)</h3>
      <p><strong>Damage:</strong> Heavy weapons (e.g. glaives, halberds) and potent spells (Inflict Wounds). Also used for percentile rolls (d100).</p>
      <p><strong>Hit Dice:</strong> Fighter, Paladin, Ranger.</p>
    </div>
    <div class="dice-section">
      <h3>D12 (12-sided die)</h3>
      <p><strong>Damage:</strong> Big hits like a greataxe or certain high-level effects.</p>
      <p><strong>Hit Dice:</strong> Barbarians are the only class with a d12.</p>
    </div>
    <div class="dice-section">
      <h3>D20 (20-sided die)</h3>
      <p><strong>Core Mechanic:</strong> Rolled for attacks, ability checks, saving throws, and initiative. A natural 20 is a critical success, while a natural 1 is often a failure.</p>
    </div>
  </div>

  <!-- Three.js and your script -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    // Custom function to create a pentagonal trapezohedron for the D10
    function createD10Geometry() {
      const alpha = 0.8;
      const phi = Math.PI / 10;
      const r = Math.sin(alpha);
      const cy = Math.cos(alpha);

      const top = [];
      const bottom = [];
      for (let i = 0; i < 5; i++) {
        let angleTop = (2 * Math.PI * i / 5) + phi;
        let angleBottom = (2 * Math.PI * i / 5) - phi;
        top.push(new THREE.Vector3(r * Math.cos(angleTop), cy, r * Math.sin(angleTop)));
        bottom.push(new THREE.Vector3(r * Math.cos(angleBottom), -cy, r * Math.sin(angleBottom)));
      }

      const vertices = [];
      for (let i = 0; i < 5; i++) {
        vertices.push(top[i].x, top[i].y, top[i].z);
      }
      for (let i = 0; i < 5; i++) {
        vertices.push(bottom[i].x, bottom[i].y, bottom[i].z);
      }

      const indices = [];
      for (let i = 0; i < 5; i++) {
        let t0 = i;
        let t1 = (i + 1) % 5;
        let b0 = i + 5;
        let b1 = ((i + 1) % 5) + 5;
        indices.push(t0, b0, t1);
        indices.push(b0, b1, t1);
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();
      return geometry;
    }

    window.addEventListener('load', function() {
      if (typeof THREE === 'undefined') {
        console.error('Three.js failed to load. Check your internet connection or the CDN link.');
        return;
      }

      const controlledAreaRadius = 7;
      const floorY = -0.5;
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      const container = document.getElementById('canvas-container');
      const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const pointLight = new THREE.PointLight(0xffffff, 1);
      pointLight.position.set(10, 10, 10);
      scene.add(pointLight);

      camera.position.z = 12;
      camera.position.y = 5;

      // Starfield
      function createStars() {
        const starCount = 1000;
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        for (let i = 0; i < starCount; i++) {
          const x = Math.random() * 2000 - 1000;
          const y = Math.random() * 2000 - 1000;
          const z = Math.random() * 2000 - 1000;
          starVertices.push(x, y, z);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
      }
      createStars();

      // Floor
      const floorGeometry = new THREE.CircleGeometry(controlledAreaRadius, 32);
      const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.8, metalness: 0.2 });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = floorY;
      scene.add(floor);

      // Border ring
      const borderGeometry = new THREE.RingGeometry(controlledAreaRadius - 0.2, controlledAreaRadius, 64);
      const borderMaterial = new THREE.MeshBasicMaterial({ color: 0xff4444, side: THREE.DoubleSide });
      const border = new THREE.Mesh(borderGeometry, borderMaterial);
      border.rotation.x = -Math.PI / 2;
      border.position.y = floorY + 0.05;
      scene.add(border);

      // Dice data
      const diceTypes = ['d4', 'd6', 'd8', 'd10', 'd12', 'd20'];
      const diceCounts = { d4: 0, d6: 0, d8: 0, d10: 0, d12: 0, d20: 0 };
      const dice = [];

      const diceColors = {
        d4: 0x8B0000,
        d6: 0x696969,
        d8: 0x2F4F4F,
        d10: 0x556B2F,
        d12: 0xB8860B,
        d20: 0x483D8B
      };

      const geometries = {
        d4: new THREE.TetrahedronGeometry(1),
        d6: new THREE.BoxGeometry(1.4, 1.4, 1.4),
        d8: new THREE.OctahedronGeometry(1),
        d10: createD10Geometry(),
        d12: new THREE.DodecahedronGeometry(1),
        d20: new THREE.IcosahedronGeometry(1)
      };

      function createDie(type) {
        const geometry = geometries[type];
        const color = diceColors[type];
        const material = new THREE.MeshStandardMaterial({
          color: color,
          metalness: 0.3,
          roughness: 0.2
        });
        const die = new THREE.Mesh(geometry, material);

        // Edges for visual clarity
        const wireframeGeometry = new THREE.EdgesGeometry(geometry);
        const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
        const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
        die.add(wireframe);

        die.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );

        die.userData = {
          type: type,
          result: 0,
          velocity: new THREE.Vector3(0, 0, 0),
          angularVelocity: new THREE.Vector3(0, 0, 0),
          isRolling: false
        };
        return die;
      }

      function addDie(type) {
        if (diceCounts[type] < 10) {
          diceCounts[type]++;
          const die = createDie(type);
          dice.push(die);
          scene.add(die);
          positionDice();
          updateControls();
        }
      }

      function removeDie(type) {
        if (diceCounts[type] > 0) {
          diceCounts[type]--;
          const index = dice.findIndex(d => d.userData.type === type);
          if (index !== -1) {
            scene.remove(dice[index]);
            dice.splice(index, 1);
            positionDice();
            updateControls();
          }
        }
      }

      function positionDice() {
        if (dice.length === 0) return;
        const spacing = 3.0;
        const rows = Math.ceil(Math.sqrt(dice.length));
        const cols = Math.ceil(dice.length / rows);
        const offsetX = ((cols - 1) * spacing) / 2;
        const offsetZ = ((rows - 1) * spacing) / 2;
        dice.forEach((die, index) => {
          const row = Math.floor(index / cols);
          const col = index % cols;
          die.position.set(
            col * spacing - offsetX,
            0.6 + Math.random() * 0.2,
            row * spacing - offsetZ
          );
          const scale = 0.9 + Math.random() * 0.2;
          die.scale.set(scale, scale, scale);
          die.rotation.set(
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2
          );
        });
      }

      function updateControls() {
        diceTypes.forEach(type => {
          const control = document.querySelector(`.dice-control[data-type="${type}"] span`);
          if (control) {
            control.textContent = `${type.toUpperCase()}: ${diceCounts[type]}`;
          }
        });
      }

      function rollDice() {
        if (dice.length === 0) return;
        const rollButton = document.getElementById('roll-button');
        rollButton.disabled = true;
        prepareDiceForRoll();

        dice.forEach(die => {
          die.userData.isRolling = true;
          die.userData.result = Math.floor(Math.random() * parseInt(die.userData.type.slice(1))) + 1;
          die.userData.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 3,
            Math.random() * 5 + 3,
            (Math.random() - 0.5) * 3
          );
          die.userData.angularVelocity = new THREE.Vector3(
            (Math.random() - 0.5) * 25,
            (Math.random() - 0.5) * 25,
            (Math.random() - 0.5) * 25
          );
        });

        setTimeout(() => {
          dice.forEach(die => {
            die.userData.isRolling = false;
          });
          displayResults();
          rollButton.disabled = false;
        }, 2500);
      }

      function prepareDiceForRoll() {
        if (dice.length === 0) return;
        const spacing = 3.0;
        const rows = Math.ceil(Math.sqrt(dice.length));
        const cols = Math.ceil(dice.length / rows);
        const offsetX = ((cols - 1) * spacing) / 2;
        const offsetZ = ((rows - 1) * spacing) / 2;
        dice.forEach((die, index) => {
          const row = Math.floor(index / cols);
          const col = index % cols;
          die.position.set(
            col * spacing - offsetX + (Math.random() * 0.5 - 0.25),
            3 + Math.random(),
            row * spacing - offsetZ + (Math.random() * 0.5 - 0.25)
          );
          die.userData.initialX = die.position.x;
          die.userData.initialZ = die.position.z;
          die.rotation.set(
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2
          );
        });
      }

      function updateDicePhysics(delta) {
        const gravity = new THREE.Vector3(0, -9.8, 0);
        dice.forEach(die => {
          if (!die.userData.isRolling) return;
          die.position.addScaledVector(die.userData.velocity, delta);
          die.rotation.x += die.userData.angularVelocity.x * delta;
          die.rotation.y += die.userData.angularVelocity.y * delta;
          die.rotation.z += die.userData.angularVelocity.z * delta;
          die.userData.velocity.addScaledVector(gravity, delta);
          die.userData.velocity.multiplyScalar(0.98);
          die.userData.angularVelocity.multiplyScalar(0.98);

          const dieRadius = 0.8;
          if (die.position.y - dieRadius < floorY) {
            die.position.y = floorY + dieRadius;
            die.userData.velocity.y *= -0.5;
            if (Math.abs(die.userData.velocity.y) < 1.0 && Math.abs(die.userData.velocity.y) > 0.1) {
              die.userData.velocity.y = Math.sign(die.userData.velocity.y) * 1.0;
            }
            die.userData.angularVelocity.x += (Math.random() - 0.5) * 5;
            die.userData.angularVelocity.z += (Math.random() - 0.5) * 5;
            die.userData.velocity.x *= 0.8;
            die.userData.velocity.z *= 0.8;
          }
          const dist = Math.sqrt(die.position.x * die.position.x + die.position.z * die.position.z);
          if (dist > controlledAreaRadius) {
            const nx = die.position.x / dist;
            const nz = die.position.z / dist;
            die.position.x = nx * controlledAreaRadius;
            die.position.z = nz * controlledAreaRadius;
            const dot = die.userData.velocity.x * nx + die.userData.velocity.z * nz;
            die.userData.velocity.x -= 2 * dot * nx * 0.8;
            die.userData.velocity.z -= 2 * dot * nz * 0.8;
            die.userData.velocity.y += 1.0;
            die.userData.angularVelocity.x += (Math.random() - 0.5) * 10;
            die.userData.angularVelocity.y += (Math.random() - 0.5) * 10;
            die.userData.angularVelocity.z += (Math.random() - 0.5) * 10;
          }
        });

        // Dice-to-dice collisions
        for (let i = 0; i < dice.length; i++) {
          if (!dice[i].userData.isRolling) continue;
          for (let j = i + 1; j < dice.length; j++) {
            if (!dice[j].userData.isRolling) continue;
            const die1 = dice[i];
            const die2 = dice[j];
            const dx = die2.position.x - die1.position.x;
            const dy = die2.position.y - die1.position.y;
            const dz = die2.position.z - die1.position.z;
            const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
            const minDist = 1.8;
            if (distance < minDist) {
              const nx = dx / distance;
              const ny = dy / distance;
              const nz = dz / distance;
              const moveAmount = (minDist - distance) / 2;
              die1.position.x -= nx * moveAmount;
              die1.position.y -= ny * moveAmount;
              die1.position.z -= nz * moveAmount;
              die2.position.x += nx * moveAmount;
              die2.position.y += ny * moveAmount;
              die2.position.z += nz * moveAmount;
              const dot1 = die1.userData.velocity.x * nx + die1.userData.velocity.y * ny + die1.userData.velocity.z * nz;
              const dot2 = die2.userData.velocity.x * nx + die2.userData.velocity.y * ny + die2.userData.velocity.z * nz;
              const bounce = 0.7;
              die1.userData.velocity.x += (dot2 - dot1) * nx * bounce;
              die1.userData.velocity.y += (dot2 - dot1) * ny * bounce;
              die1.userData.velocity.z += (dot2 - dot1) * nz * bounce;
              die2.userData.velocity.x += (dot1 - dot2) * nx * bounce;
              die2.userData.velocity.y += (dot1 - dot2) * ny * bounce;
              die2.userData.velocity.z += (dot1 - dot2) * nz * bounce;
              const spinAmount = 5.0;
              die1.userData.angularVelocity.x += (Math.random() - 0.5) * spinAmount;
              die1.userData.angularVelocity.y += (Math.random() - 0.5) * spinAmount;
              die1.userData.angularVelocity.z += (Math.random() - 0.5) * spinAmount;
              die2.userData.angularVelocity.x += (Math.random() - 0.5) * spinAmount;
              die2.userData.angularVelocity.y += (Math.random() - 0.5) * spinAmount;
              die2.userData.angularVelocity.z += (Math.random() - 0.5) * spinAmount;
            }
          }
        }

        // Snap to rest
        dice.forEach(die => {
          if (!die.userData.isRolling &&
              die.userData.velocity.length() < 0.1 &&
              die.userData.angularVelocity.length() < 0.1) {
            const type = die.userData.type;
            const euler = new THREE.Euler().setFromQuaternion(die.quaternion);
            if (type === 'd6') {
              euler.x = Math.round(euler.x / (Math.PI / 2)) * (Math.PI / 2);
              euler.z = Math.round(euler.z / (Math.PI / 2)) * (Math.PI / 2);
            } else {
              euler.x = Math.round(euler.x / (Math.PI / 4)) * (Math.PI / 4);
              euler.y = Math.round(euler.y / (Math.PI / 4)) * (Math.PI / 4);
              euler.z = Math.round(euler.z / (Math.PI / 4)) * (Math.PI / 4);
            }
            die.quaternion.setFromEuler(euler);
            die.userData.velocity.set(0, 0, 0);
            die.userData.angularVelocity.set(0, 0, 0);
          }
        });
      }

      function displayResults() {
        const rollLog = document.getElementById('roll-log');
        const resultsByType = {};
        let totalSum = 0;

        dice.forEach(die => {
          const type = die.userData.type;
          const result = die.userData.result;
          if (!resultsByType[type]) {
            resultsByType[type] = [];
          }
          resultsByType[type].push(result);
          totalSum += result;
        });

        let resultHTML = '';
        for (const type in resultsByType) {
          if (resultsByType[type].length > 0) {
            resultHTML += `<span class="${type}-result">${type.toUpperCase()}: [${resultsByType[type].join(', ')}]</span> `;
          }
        }
        resultHTML += `<span class="total-result">Total: ${totalSum}</span>`;

        const logEntry = document.createElement('li');
        logEntry.innerHTML = resultHTML;
        rollLog.insertBefore(logEntry, rollLog.firstChild);

        // Keep only the most recent 10 rolls
        while (rollLog.children.length > 10) {
          rollLog.removeChild(rollLog.lastChild);
        }
      }

      // Event listeners
      document.querySelectorAll('.dice-control .add').forEach(button => {
        button.addEventListener('click', function() {
          const type = this.parentElement.dataset.type;
          addDie(type);
        });
      });
      document.querySelectorAll('.dice-control .remove').forEach(button => {
        button.addEventListener('click', function() {
          const type = this.parentElement.dataset.type;
          removeDie(type);
        });
      });
      document.getElementById('roll-button').addEventListener('click', rollDice);

      let lastTime = 0;
      function animate(time) {
        requestAnimationFrame(animate);
        const delta = Math.min((time - lastTime) / 1000, 0.1);
        lastTime = time;
        updateDicePhysics(delta);
        renderer.render(scene, camera);
      }
      animate(0);

      window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });

      // Add one of each die to start
      addDie('d4');
      addDie('d6');
      addDie('d8');
      addDie('d10');
      addDie('d12');
      addDie('d20');
    });
  </script>
</body>
</html>
