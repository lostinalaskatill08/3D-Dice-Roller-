<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D D&D Dice Roller with Physics</title>
  <link rel="icon" href="data:,">
  <style>
    /* General layout & styling */
    body {
      margin: 0;
      background-color: #1a1a1a;
      color: #fff;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }
    #controls {
      margin: 20px 0;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
    }
    .dice-control {
      background-color: #ff4444;
      padding: 10px;
      margin: 5px;
      border-radius: 5px;
      display: flex;
      align-items: center;
    }
    .dice-control span {
      margin: 0 10px;
      color: yellow;
      font-weight: bold;
    }
    /* Revert buttons to original styling */
    .dice-control button {
      background-color: yellow;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      font-weight: bold;
      border-radius: 3px;
    }
    .dice-control button:hover {
      background-color: #e6e600;
    }
    #canvas-container {
      width: 80%;
      height: 50%;
      border: 2px solid #ff4444;
      background-color: #000;
      position: relative;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(255,255,255,0.1);
    }
    #roll-button {
      margin: 10px 0;
      padding: 10px 20px;
      background-color: #4444ff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
    }
    #roll-button:hover {
      background-color: #3333cc;
    }
    #results {
      background-color: #222;
      padding: 10px;
      border: 1px solid yellow;
      border-radius: 5px;
      width: 80%;
      max-height: 200px;
      overflow-y: auto;
      color: #fff;
    }
    /* Header outside the scroll area */
    #results-header {
      color: yellow;
      margin: 0 0 5px 0;
      padding: 5px 0;
      font-size: 16px;
      font-weight: bold;
      text-align: center;
      width: 80%;
    }
    #roll-log {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    #roll-log li {
      padding: 8px;
      margin-bottom: 5px;
      background-color: #333;
      border-radius: 4px;
    }
    #roll-log li:nth-child(odd) {
      background-color: #2a2a2a;
    }
    .die-result {
      display: inline-block;
      padding: 3px 6px;
      margin: 0 3px;
      border-radius: 3px;
      font-weight: bold;
    }
    /* Die result backgrounds matching D&D-themed dice colors */
    .d4-result { background-color: rgba(139, 0, 0, 0.5); }
    .d6-result { background-color: rgba(105, 105, 105, 0.5); }
    .d8-result { background-color: rgba(47, 79, 79, 0.5); }
    .d10-result { background-color: rgba(85, 107, 47, 0.5); }
    .d12-result { background-color: rgba(184, 134, 11, 0.5); }
    .d20-result { background-color: rgba(72, 61, 139, 0.5); }
    .total-result {
      background-color: #ff9900;
      color: white;
      padding: 3px 8px;
      border-radius: 4px;
      margin-left: 8px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <div class="dice-control" data-type="d4">
      <button class="remove">-</button>
      <span>D4: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d6">
      <button class="remove">-</button>
      <span>D6: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d8">
      <button class="remove">-</button>
      <span>D8: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d10">
      <button class="remove">-</button>
      <span>D10: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d12">
      <button class="remove">-</button>
      <span>D12: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d20">
      <button class="remove">-</button>
      <span>D20: 0</span>
      <button class="add">+</button>
    </div>
  </div>
  <div id="canvas-container"></div>
  <button id="roll-button">Roll Dice</button>
  <div id="results-header">Roll Results</div>
  <div id="results">
    <ul id="roll-log"></ul>
  </div>

  <!-- Load Three.js and Cannon-es as ES modules -->
  <script type="module">
    import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.module.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    // --- Custom D10 Geometry: Pentagonal Trapezohedron ---
    function createD10Geometry() {
      const alpha = 0.8;
      const phi = Math.PI / 10;
      const r = Math.sin(alpha);
      const cy = Math.cos(alpha);
      const top = [];
      const bottom = [];
      for (let i = 0; i < 5; i++) {
        const angleTop = (2 * Math.PI * i / 5) + phi;
        const angleBottom = (2 * Math.PI * i / 5) - phi;
        top.push(new THREE.Vector3(r * Math.cos(angleTop), cy, r * Math.sin(angleTop)));
        bottom.push(new THREE.Vector3(r * Math.cos(angleBottom), -cy, r * Math.sin(angleBottom)));
      }
      const vertices = [];
      for (let i = 0; i < 5; i++) {
        vertices.push(top[i]);
      }
      for (let i = 0; i < 5; i++) {
        vertices.push(bottom[i]);
      }
      const indices = [];
      for (let i = 0; i < 5; i++) {
        const t0 = i;
        const t1 = (i + 1) % 5;
        const b0 = i + 5;
        const b1 = ((i + 1) % 5) + 5;
        indices.push(t0, b0, t1);
        indices.push(b0, b1, t1);
      }
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      for (let v of vertices) {
        positions.push(v.x, v.y, v.z);
      }
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();
      return geometry;
    }

    // --- Helper: Convert THREE.BufferGeometry to a Cannon ConvexPolyhedron ---
    function createConvexShapeFromGeometry(geometry) {
      const positionAttr = geometry.attributes.position;
      const vertices = [];
      for (let i = 0; i < positionAttr.count; i++) {
        const vertex = new CANNON.Vec3().copy(new THREE.Vector3().fromBufferAttribute(positionAttr, i));
        vertices.push(vertex);
      }
      const indices = geometry.index ? geometry.index.array : null;
      const faces = [];
      if (indices) {
        for (let i = 0; i < indices.length; i += 3) {
          faces.push([ indices[i], indices[i+1], indices[i+2] ]);
        }
      } else {
        for (let i = 0; i < vertices.length; i += 3) {
          faces.push([ i, i+1, i+2 ]);
        }
      }
      return new CANNON.ConvexPolyhedron({ vertices, faces });
    }

    // --- Setup Three.js Scene ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    const container = document.getElementById('canvas-container');
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);
    const camera = new THREE.PerspectiveCamera(75, container.clientWidth/container.clientHeight, 0.1, 1000);
    camera.position.set(0, 5, 12);
    camera.lookAt(0, 0, 0);
    scene.add(camera);

    // --- Lighting ---
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const pointLight = new THREE.PointLight(0xffffff, 1);
    pointLight.position.set(10, 10, 10);
    scene.add(pointLight);

    // --- Setup Cannon-es World ---
    const world = new CANNON.World({
      gravity: new CANNON.Vec3(0, -9.82, 0),
      allowSleep: true
    });
    // Use grid-based broadphase for efficient collision detection
    world.broadphase = new CANNON.GridBroadphase(
      new CANNON.Vec3(-20, -20, -20),
      new CANNON.Vec3(20, 20, 20),
      10, 10, 10
    );
    world.solver.iterations = 15;
    world.solver.tolerance = 0.001;
    world.defaultContactMaterial.friction = 0.6;
    world.defaultContactMaterial.restitution = 0.3;

    // --- Floor and Platform ---
    const controlledAreaRadius = 7;
    const floorY = -0.5;
    const floorGeometry = new THREE.CircleGeometry(controlledAreaRadius, 32);
    const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
    const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
    floorMesh.rotation.x = -Math.PI/2;
    floorMesh.position.y = floorY;
    scene.add(floorMesh);
    // Cannon floor body
    const floorBody = new CANNON.Body({ mass: 0 });
    floorBody.addShape(new CANNON.Plane());
    floorBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
    floorBody.position.y = floorY;
    world.addBody(floorBody);

    // Border for the platform
    const borderGeometry = new THREE.RingGeometry(controlledAreaRadius - 0.2, controlledAreaRadius, 64);
    const borderMaterial = new THREE.MeshBasicMaterial({ color: 0xff4444, side: THREE.DoubleSide });
    const borderMesh = new THREE.Mesh(borderGeometry, borderMaterial);
    borderMesh.rotation.x = -Math.PI/2;
    borderMesh.position.y = floorY + 0.05;
    scene.add(borderMesh);

    // --- Dice Management ---
    const diceTypes = ['d4', 'd6', 'd8', 'd10', 'd12', 'd20'];
    const diceCounts = { d4: 0, d6: 0, d8: 0, d10: 0, d12: 0, d20: 0 };
    const diceMeshes = [];
    const diceBodies = [];

    // D&Dâ€“themed colors (note: D6 changed to dark gray)
    const diceColors = {
      d4: 0x8B0000,
      d6: 0x696969,
      d8: 0x2F4F4F,
      d10: 0x556B2F,
      d12: 0xB8860B,
      d20: 0x483D8B
    };

    // Three.js geometries for dice
    const geometries = {
      d4: new THREE.TetrahedronGeometry(1),
      d6: new THREE.BoxGeometry(1.4, 1.4, 1.4),
      d8: new THREE.OctahedronGeometry(1),
      d10: createD10Geometry(),
      d12: new THREE.DodecahedronGeometry(1),
      d20: new THREE.IcosahedronGeometry(1)
    };

    // Create physics shape â€“ for d6 use Box; for others, create convex shape from geometry.
    function createPhysicsShape(type, geometry) {
      if (type === 'd6') {
        const hx = 1.4/2, hy = 1.4/2, hz = 1.4/2;
        return new CANNON.Box(new CANNON.Vec3(hx, hy, hz));
      } else {
        return createConvexShapeFromGeometry(geometry);
      }
    }

    // Create a die (Three.js mesh and Cannon body) for a given type.
    function createDie(type) {
      const geom = geometries[type];
      const material = new THREE.MeshStandardMaterial({
        color: diceColors[type],
        metalness: 0.3,
        roughness: 0.2
      });
      const mesh = new THREE.Mesh(geom, material);
      // Add wireframe
      const wireframe = new THREE.LineSegments(new THREE.EdgesGeometry(geom), new THREE.LineBasicMaterial({ color: 0xffffff }));
      mesh.add(wireframe);
      mesh.rotation.set(Math.random()*Math.PI*2, Math.random()*Math.PI*2, Math.random()*Math.PI*2);
      scene.add(mesh);

      // Create Cannon body for physics
      const shape = createPhysicsShape(type, geom);
      const body = new CANNON.Body({
        mass: 1,
        shape: shape,
        material: new CANNON.Material('dice')
      });
      // Random initial position (spread out within controlled area)
      body.position.set((Math.random()-0.5)*8, 5 + Math.random(), (Math.random()-0.5)*8);
      // Apply random initial velocity and angular velocity for a dynamic roll
      body.velocity.set((Math.random()-0.5)*5, Math.random()*5, (Math.random()-0.5)*5);
      body.angularVelocity.set((Math.random()-0.5)*25, (Math.random()-0.5)*25, (Math.random()-0.5)*25);
      body.linearDamping = 0.1;
      body.angularDamping = 0.2;
      body.sleepSpeedLimit = 0.1;
      body.sleepTimeLimit = 1.0;
      world.addBody(body);

      // Store additional info: type and a randomly computed roll result
      body.userData = { type: type, result: Math.floor(Math.random()*parseInt(type.slice(1)))+1 };

      diceMeshes.push(mesh);
      diceBodies.push(body);
    }

    // Functions to add and remove dice via UI
    function addDie(type) {
      if (diceCounts[type] < 10) {
        diceCounts[type]++;
        createDie(type);
        positionDice();
        updateControls();
      }
    }
    function removeDie(type) {
      if (diceCounts[type] > 0) {
        diceCounts[type]--;
        for (let i = 0; i < diceBodies.length; i++) {
          if (diceBodies[i].userData.type === type) {
            scene.remove(diceMeshes[i]);
            world.removeBody(diceBodies[i]);
            diceMeshes.splice(i, 1);
            diceBodies.splice(i, 1);
            break;
          }
        }
        positionDice();
        updateControls();
      }
    }

    // Arrange dice in a grid for improved horizontal separation
    function positionDice() {
      const count = diceMeshes.length;
      if (count === 0) return;
      const spacing = 3.0;
      const rows = Math.ceil(Math.sqrt(count));
      const cols = Math.ceil(count / rows);
      const offsetX = ((cols - 1) * spacing) / 2;
      const offsetZ = ((rows - 1) * spacing) / 2;
      for (let i = 0; i < count; i++) {
        const row = Math.floor(i / cols);
        const col = i % cols;
        const x = col * spacing - offsetX;
        const z = row * spacing - offsetZ;
        // Reposition dice bodies (only X and Z; Y remains as simulated)
        diceBodies[i].position.x = x + (Math.random()*0.5 - 0.25);
        diceBodies[i].position.z = z + (Math.random()*0.5 - 0.25);
      }
    }

    function updateControls() {
      diceTypes.forEach(type => {
        const control = document.querySelector(`.dice-control[data-type="${type}"] span`);
        if (control) {
          control.textContent = `${type.toUpperCase()}: ${diceCounts[type]}`;
        }
      });
    }

    // When "Roll Dice" is pressed, reassign random velocities and update each die's random result.
    function rollDice() {
      if (diceBodies.length === 0) return;
      document.getElementById('roll-button').disabled = true;
      positionDice();
      diceBodies.forEach(body => {
        body.wakeUp();
        body.velocity.set((Math.random()-0.5)*5, Math.random()*5+3, (Math.random()-0.5)*5);
        body.angularVelocity.set((Math.random()-0.5)*25, (Math.random()-0.5)*25, (Math.random()-0.5)*25);
        body.userData.result = Math.floor(Math.random()*parseInt(body.userData.type.slice(1)))+1;
      });
      // Let simulation run for 2.5 seconds before displaying results.
      setTimeout(() => {
        const resultsByType = {};
        let total = 0;
        diceBodies.forEach(body => {
          const type = body.userData.type;
          const res = body.userData.result;
          if (!resultsByType[type]) resultsByType[type] = [];
          resultsByType[type].push(res);
          total += res;
        });
        let resultHTML = '';
        for (let type in resultsByType) {
          resultHTML += `<span class="${type}-result">${type.toUpperCase()}: [${resultsByType[type].join(', ')}]</span> `;
        }
        resultHTML += `<span class="total-result">Total: ${total}</span>`;
        const logEntry = document.createElement('li');
        logEntry.innerHTML = resultHTML;
        const rollLog = document.getElementById('roll-log');
        rollLog.insertBefore(logEntry, rollLog.firstChild);
        while (rollLog.children.length > 10) {
          rollLog.removeChild(rollLog.lastChild);
        }
        document.getElementById('roll-button').disabled = false;
      }, 2500);
    }

    // Attach event listeners to UI buttons.
    document.querySelectorAll('.dice-control .add').forEach(button => {
      button.addEventListener('click', function() {
        const type = this.parentElement.dataset.type;
        addDie(type);
      });
    });
    document.querySelectorAll('.dice-control .remove').forEach(button => {
      button.addEventListener('click', function() {
        const type = this.parentElement.dataset.type;
        removeDie(type);
      });
    });
    document.getElementById('roll-button').addEventListener('click', rollDice);

    // --- Animation Loop ---
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      world.step(1/60, delta, 3);
      // Synchronize each Three.js mesh with its Cannon body.
      for (let i = 0; i < diceMeshes.length; i++) {
        diceMeshes[i].position.copy(diceBodies[i].position);
        diceMeshes[i].quaternion.copy(diceBodies[i].quaternion);
      }
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });

    // Add one of each die initially.
    addDie('d4');
    addDie('d6');
    addDie('d8');
    addDie('d10');
    addDie('d12');
    addDie('d20');
  </script>
</body>
</html>
