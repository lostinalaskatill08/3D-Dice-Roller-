<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D D&D Dice Roller</title>
  <link rel="icon" href="data:,">
  <!-- Import Cinzel font from Google Fonts -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');

    body {
      margin: 0;
      background-color: #1a1a1a; /* Dark background */
      color: #fafafa;
      font-family: 'Cinzel', serif; /* Cinzel for entire page, including buttons */
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #controls {
      margin: 20px 0;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
    }
    .dice-control {
      background-color: #8B0000; /* Red button background */
      padding: 10px;
      margin: 5px;
      border-radius: 5px;
      display: flex;
      align-items: center;
      border: 1px solid #440000; /* Slightly darker red border */
    }
    .dice-control span {
      margin: 0 10px;
      font-weight: bold;
    }
    .dice-control button {
      background-color: #8B0000;
      color: #fafafa;
      border: 1px solid #440000;
      padding: 5px 10px;
      cursor: pointer;
      font-weight: bold;
      border-radius: 3px;
      font-family: 'Cinzel', serif;
    }
    .dice-control button:hover {
      background-color: #6d0101;
    }

    /* 3D viewer with red border */
    #canvas-container {
      width: 80%;
      height: 400px;
      border: 2px solid red;
      position: relative;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(255,255,255,0.1);
      margin-bottom: 10px;
      background-color: #000;
    }

    /* Buttons remain red, with Cinzel font */
    #roll-button,
    #copy-log-button {
      margin: 10px 5px;
      padding: 10px 20px;
      background-color: #8B0000;
      color: #fafafa;
      border: 1px solid #440000;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      font-family: 'Cinzel', serif;
    }
    #roll-button:hover,
    #copy-log-button:hover {
      background-color: #6d0101;
    }

    /* Roll Results container with red border */
    #results-header {
      margin: 0 0 5px 0;
      padding: 5px 0;
      font-size: 16px;
      font-weight: bold;
      text-align: center;
      width: 80%;
      color: #fafafa;
      font-family: 'Cinzel', serif;
    }
    #results {
      background-color: #2a2a2a;
      padding: 10px;
      border: 2px solid red;
      border-radius: 5px;
      width: 80%;
      max-height: 300px;
      overflow-y: auto;
      color: #fafafa;
      margin-bottom: 10px;
    }
    #roll-log {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    #roll-log li {
      padding: 8px;
      margin-bottom: 5px;
      background-color: #333;
      border-radius: 4px;
      font-family: 'Cinzel', serif;
    }
    #roll-log li:nth-child(odd) {
      background-color: #2a2a2a;
    }

    /* Dice result backgrounds */
    .d4-result    { background-color: rgba(139, 0, 0, 0.6); }
    .d6-result    { background-color: rgba(0, 0, 139, 0.6); }
    .d8-result    { background-color: rgba(75, 0, 130, 0.6); }
    .d10-result   { background-color: rgba(0, 100, 0, 0.6); }
    .d12-result   { background-color: rgba(204, 204, 0, 0.6); }
    .d20-result   { background-color: rgba(255, 140, 0, 0.6); }

    .total-result {
      background-color: red; /* Updated to match border */
      color: #fafafa;
      padding: 3px 8px;
      border-radius: 4px;
      margin-left: 8px;
      font-weight: bold;
      font-family: 'Cinzel', serif;
    }

    /* Dice Usage Information section with red border */
    #dice-info {
      background-color: #2a2a2a;
      color: #fafafa;
      border: 2px solid red;
      border-radius: 5px;
      width: 80%;
      padding: 10px;
      margin-top: 10px;
      max-height: 300px;
      overflow-y: auto;
    }
    #dice-info h2, #dice-info h3 {
      color: #fafafa;
      text-align: center;
      margin: 10px 0 5px;
      font-family: 'Cinzel', serif;
    }
    #dice-info p {
      margin: 5px 0;
      font-size: 14px;
      font-family: 'Cinzel', serif;
    }
  </style>
</head>
<body>
  <!-- Dice Controls -->
  <div id="controls">
    <div class="dice-control" data-type="d4">
      <button class="remove">-</button>
      <span>D4: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d6">
      <button class="remove">-</button>
      <span>D6: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d8">
      <button class="remove">-</button>
      <span>D8: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d10">
      <button class="remove">-</button>
      <span>D10: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d12">
      <button class="remove">-</button>
      <span>D12: 0</span>
      <button class="add">+</button>
    </div>
    <div class="dice-control" data-type="d20">
      <button class="remove">-</button>
      <span>D20: 0</span>
      <button class="add">+</button>
    </div>
  </div>

  <!-- 3D Dice Container -->
  <div id="canvas-container"></div>

  <!-- Roll & Copy Log Buttons -->
  <div>
    <button id="roll-button">Roll Dice</button>
    <button id="copy-log-button">Copy Log</button>
  </div>

  <!-- Roll Results -->
  <div id="results-header">Roll Results</div>
  <div id="results">
    <ul id="roll-log"></ul>
  </div>

  <!-- Dice Usage Information -->
  <div id="dice-info">
    <h2>Dice Usage Information</h2>
    <div class="dice-section">
      <h3>D4 (4-sided die)</h3>
      <p><strong>Damage:</strong> Used for low-damage rolls (e.g. daggers, minor spells) and small healing effects.</p>
      <p><strong>Bonus:</strong> Sometimes adds a small bonus to d20 rolls (e.g. Bless, Guidance).</p>
    </div>
    <div class="dice-section">
      <h3>D6 (6-sided die)</h3>
      <p><strong>Damage:</strong> Frequently rolled for weapon damage (shortswords, handaxes) and big spells (Fireball with multiple d6s).</p>
      <p><strong>Ability Scores:</strong> Commonly used for 4d6 drop-lowest ability score generation.</p>
      <p><strong>Hit Dice:</strong> Wizards/Sorcerers use a d6 for HP growth.</p>
    </div>
    <div class="dice-section">
      <h3>D8 (8-sided die)</h3>
      <p><strong>Damage:</strong> Standard for one-handed martial weapons (longswords, rapiers) and many spells.</p>
      <p><strong>Hit Dice:</strong> Mid-tier classes (Cleric, Druid, Rogue, Bard, Monk).</p>
    </div>
    <div class="dice-section">
      <h3>D10 (10-sided die)</h3>
      <p><strong>Damage:</strong> Heavy weapons (e.g. glaives, halberds) and potent spells (Inflict Wounds). Also used for percentile rolls (d100).</p>
      <p><strong>Hit Dice:</strong> Fighter, Paladin, Ranger.</p>
    </div>
    <div class="dice-section">
      <h3>D12 (12-sided die)</h3>
      <p><strong>Damage:</strong> Big hits like a greataxe or certain high-level effects.</p>
      <p><strong>Hit Dice:</strong> Barbarians are the only class with a d12.</p>
    </div>
    <div class="dice-section">
      <h3>D20 (20-sided die)</h3>
      <p><strong>Core Mechanic:</strong> Rolled for attacks, ability checks, saving throws, and initiative. A natural 20 is a critical success, while a natural 1 is often a failure.</p>
    </div>
  </div>

  <!-- Three.js and Dice Roller Script -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    const floorY = -0.5;
    const floorSize = 24;
    const borderSize = 26;
    const halfSize = floorSize / 2;
    const shootingStars = [];

    function randomBetween(min, max) {
      return Math.random() * (max - min) + min;
    }

    function spawnShootingStar() {
      const geometry = new THREE.SphereGeometry(0.15, 8, 8);
      const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const star = new THREE.Mesh(geometry, material);
      star.position.set(
        randomBetween(-30, 30),
        randomBetween(10, 40),
        randomBetween(-200, -300)
      );
      star.userData.velocity = new THREE.Vector3(
        randomBetween(-1, 1),
        randomBetween(-0.2, -0.5),
        randomBetween(50, 80)
      );
      scene.add(star);
      shootingStars.push(star);
    }

    function updateShootingStars(delta) {
      for (let i = shootingStars.length - 1; i >= 0; i--) {
        const star = shootingStars[i];
        star.position.addScaledVector(star.userData.velocity, delta);
        if (
          star.position.z > 50 ||
          star.position.y < -10 ||
          star.position.x < -100 || star.position.x > 100
        ) {
          scene.remove(star);
          shootingStars.splice(i, 1);
        }
      }
    }

    function createD10Geometry() {
      const alpha = 0.8;
      const phi = Math.PI / 10;
      const r = Math.sin(alpha);
      const cy = Math.cos(alpha);
      const top = [];
      const bottom = [];
      for (let i = 0; i < 5; i++) {
        let angleTop = (2 * Math.PI * i / 5) + phi;
        let angleBottom = (2 * Math.PI * i / 5) - phi;
        top.push(new THREE.Vector3(r * Math.cos(angleTop), cy, r * Math.sin(angleTop)));
        bottom.push(new THREE.Vector3(r * Math.cos(angleBottom), -cy, r * Math.sin(angleBottom)));
      }
      const vertices = [];
      for (let i = 0; i < 5; i++) {
        vertices.push(top[i].x, top[i].y, top[i].z);
      }
      for (let i = 0; i < 5; i++) {
        vertices.push(bottom[i].x, bottom[i].y, bottom[i].z);
      }
      const indices = [];
      for (let i = 0; i < 5; i++) {
        let t0 = i;
        let t1 = (i + 1) % 5;
        let b0 = i + 5;
        let b1 = ((i + 1) % 5) + 5;
        indices.push(t0, b0, t1);
        indices.push(b0, b1, t1);
      }
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();
      return geometry;
    }

    let scene, camera, renderer;
    const diceTypes = ['d4', 'd6', 'd8', 'd10', 'd12', 'd20'];
    const diceCounts = { d4: 0, d6: 0, d8: 0, d10: 0, d12: 0, d20: 0 };
    const dice = [];
    const diceColors = {
      d4:  0x8B0000,
      d6:  0x00008B,
      d8:  0x4B0082,
      d10: 0x006400,
      d12: 0xCCCC00,
      d20: 0xFF8C00
    };
    const geometries = {
      d4:  new THREE.TetrahedronGeometry(1),
      d6:  new THREE.BoxGeometry(1.4, 1.4, 1.4),
      d8:  new THREE.OctahedronGeometry(1),
      d10: createD10Geometry(),
      d12: new THREE.DodecahedronGeometry(1),
      d20: new THREE.IcosahedronGeometry(1)
    };

    function createDie(type) {
      const geometry = geometries[type];
      const color = diceColors[type];
      const material = new THREE.MeshStandardMaterial({
        color: color,
        metalness: 0.3,
        roughness: 0.2
      });
      const die = new THREE.Mesh(geometry, material);
      const wireframeGeometry = new THREE.EdgesGeometry(geometry);
      const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
      const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
      die.add(wireframe);
      die.rotation.set(
        Math.random() * Math.PI * 2,
        Math.random() * Math.PI * 2,
        Math.random() * Math.PI * 2
      );
      die.userData = {
        type: type,
        result: 0,
        velocity: new THREE.Vector3(0, 0, 0),
        angularVelocity: new THREE.Vector3(0, 0, 0),
        isRolling: false
      };
      return die;
    }

    function addDie(type) {
      if (diceCounts[type] < 10) {
        diceCounts[type]++;
        const die = createDie(type);
        dice.push(die);
        scene.add(die);
        positionDice();
        updateControls();
      }
    }

    function removeDie(type) {
      if (diceCounts[type] > 0) {
        diceCounts[type]--;
        const index = dice.findIndex(d => d.userData.type === type);
        if (index !== -1) {
          scene.remove(dice[index]);
          dice.splice(index, 1);
          positionDice();
          updateControls();
        }
      }
    }

    function positionDice() {
      if (dice.length === 0) return;
      const spacing = 3.0;
      const rows = Math.ceil(Math.sqrt(dice.length));
      const cols = Math.ceil(dice.length / rows);
      const offsetX = ((cols - 1) * spacing) / 2;
      const offsetZ = ((rows - 1) * spacing) / 2;
      dice.forEach((die, index) => {
        const row = Math.floor(index / cols);
        const col = index % cols;
        die.position.set(
          col * spacing - offsetX,
          0.6 + Math.random() * 0.2,
          row * spacing - offsetZ
        );
        const scale = 0.9 + Math.random() * 0.2;
        die.scale.set(scale, scale, scale);
        die.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );
      });
    }

    function updateControls() {
      diceTypes.forEach(type => {
        const control = document.querySelector(`.dice-control[data-type="${type}"] span`);
        if (control) {
          control.textContent = `${type.toUpperCase()}: ${diceCounts[type]}`;
        }
      });
    }

    function rollDice() {
      if (dice.length === 0) return;
      const rollButton = document.getElementById('roll-button');
      rollButton.disabled = true;
      prepareDiceForRoll();
      dice.forEach(die => {
        die.userData.isRolling = true;
        const sides = parseInt(die.userData.type.slice(1));
        die.userData.result = Math.floor(Math.random() * sides) + 1;
        die.userData.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 3,
          Math.random() * 5 + 3,
          (Math.random() - 0.5) * 3
        );
        die.userData.angularVelocity = new THREE.Vector3(
          (Math.random() - 0.5) * 25,
          (Math.random() - 0.5) * 25,
          (Math.random() - 0.5) * 25
        );
      });
      setTimeout(() => {
        dice.forEach(die => {
          die.userData.isRolling = false;
        });
        displayResults();
        rollButton.disabled = false;
      }, 2500);
    }

    function prepareDiceForRoll() {
      if (dice.length === 0) return;
      const spacing = 3.0;
      const rows = Math.ceil(Math.sqrt(dice.length));
      const cols = Math.ceil(dice.length / rows);
      const offsetX = ((cols - 1) * spacing) / 2;
      const offsetZ = ((rows - 1) * spacing) / 2;
      dice.forEach((die, index) => {
        const row = Math.floor(index / cols);
        const col = index % cols;
        die.position.set(
          col * spacing - offsetX + (Math.random() * 0.5 - 0.25),
          3 + Math.random(),
          row * spacing - offsetZ + (Math.random() * 0.5 - 0.25)
        );
        die.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );
      });
    }

    function updateDicePhysics(delta) {
      const gravity = new THREE.Vector3(0, -9.8, 0);
      dice.forEach(die => {
        if (!die.userData.isRolling) return;
        die.position.addScaledVector(die.userData.velocity, delta);
        die.rotation.x += die.userData.angularVelocity.x * delta;
        die.rotation.y += die.userData.angularVelocity.y * delta;
        die.rotation.z += die.userData.angularVelocity.z * delta;
        die.userData.velocity.addScaledVector(gravity, delta);
        die.userData.velocity.multiplyScalar(0.98);
        die.userData.angularVelocity.multiplyScalar(0.98);
        const dieRadius = 0.8;
        if (die.position.y - dieRadius < floorY) {
          die.position.y = floorY + dieRadius;
          die.userData.velocity.y *= -0.5;
          die.userData.velocity.x *= 0.8;
          die.userData.velocity.z *= 0.8;
          die.userData.angularVelocity.x += (Math.random() - 0.5) * 5;
          die.userData.angularVelocity.z += (Math.random() - 0.5) * 5;
        }
        if (die.position.x < -halfSize) {
          die.position.x = -halfSize;
          die.userData.velocity.x *= -0.5;
          die.userData.angularVelocity.x += (Math.random() - 0.5) * 10;
          die.userData.angularVelocity.y += (Math.random() - 0.5) * 10;
          die.userData.angularVelocity.z += (Math.random() - 0.5) * 10;
        }
        if (die.position.x > halfSize) {
          die.position.x = halfSize;
          die.userData.velocity.x *= -0.5;
          die.userData.angularVelocity.x += (Math.random() - 0.5) * 10;
          die.userData.angularVelocity.y += (Math.random() - 0.5) * 10;
          die.userData.angularVelocity.z += (Math.random() - 0.5) * 10;
        }
        if (die.position.z < -halfSize) {
          die.position.z = -halfSize;
          die.userData.velocity.z *= -0.5;
          die.userData.angularVelocity.x += (Math.random() - 0.5) * 10;
          die.userData.angularVelocity.y += (Math.random() - 0.5) * 10;
          die.userData.angularVelocity.z += (Math.random() - 0.5) * 10;
        }
        if (die.position.z > halfSize) {
          die.position.z = halfSize;
          die.userData.velocity.z *= -0.5;
          die.userData.angularVelocity.x += (Math.random() - 0.5) * 10;
          die.userData.angularVelocity.y += (Math.random() - 0.5) * 10;
          die.userData.angularVelocity.z += (Math.random() - 0.5) * 10;
        }
      });
      for (let i = 0; i < dice.length; i++) {
        if (!dice[i].userData.isRolling) continue;
        for (let j = i + 1; j < dice.length; j++) {
          if (!dice[j].userData.isRolling) continue;
          const die1 = dice[i];
          const die2 = dice[j];
          const dx = die2.position.x - die1.position.x;
          const dy = die2.position.y - die1.position.y;
          const dz = die2.position.z - die1.position.z;
          const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
          const minDist = 1.8;
          if (distance < minDist) {
            const nx = dx / distance;
            const ny = dy / distance;
            const nz = dz / distance;
            const overlap = (minDist - distance) / 2;
            die1.position.x -= nx * overlap;
            die1.position.y -= ny * overlap;
            die1.position.z -= nz * overlap;
            die2.position.x += nx * overlap;
            die2.position.y += ny * overlap;
            die2.position.z += nz * overlap;
            const dot1 = die1.userData.velocity.x * nx + die1.userData.velocity.y * ny + die1.userData.velocity.z * nz;
            const dot2 = die2.userData.velocity.x * nx + die2.userData.velocity.y * ny + die2.userData.velocity.z * nz;
            const bounce = 0.7;
            die1.userData.velocity.x += (dot2 - dot1) * nx * bounce;
            die1.userData.velocity.y += (dot2 - dot1) * ny * bounce;
            die1.userData.velocity.z += (dot2 - dot1) * nz * bounce;
            die2.userData.velocity.x += (dot1 - dot2) * nx * bounce;
            die2.userData.velocity.y += (dot1 - dot2) * ny * bounce;
            die2.userData.velocity.z += (dot1 - dot2) * nz * bounce;
            const spinAmount = 5.0;
            die1.userData.angularVelocity.x += (Math.random() - 0.5) * spinAmount;
            die1.userData.angularVelocity.y += (Math.random() - 0.5) * spinAmount;
            die1.userData.angularVelocity.z += (Math.random() - 0.5) * spinAmount;
            die2.userData.angularVelocity.x += (Math.random() - 0.5) * spinAmount;
            die2.userData.angularVelocity.y += (Math.random() - 0.5) * spinAmount;
            die2.userData.angularVelocity.z += (Math.random() - 0.5) * spinAmount;
          }
        }
      }
      dice.forEach(die => {
        if (!die.userData.isRolling &&
            die.userData.velocity.length() < 0.1 &&
            die.userData.angularVelocity.length() < 0.1) {
          const type = die.userData.type;
          const euler = new THREE.Euler().setFromQuaternion(die.quaternion);
          if (type === 'd6') {
            euler.x = Math.round(euler.x / (Math.PI / 2)) * (Math.PI / 2);
            euler.z = Math.round(euler.z / (Math.PI / 2)) * (Math.PI / 2);
          } else {
            euler.x = Math.round(euler.x / (Math.PI / 4)) * (Math.PI / 4);
            euler.y = Math.round(euler.y / (Math.PI / 4)) * (Math.PI / 4);
            euler.z = Math.round(euler.z / (Math.PI / 4)) * (Math.PI / 4);
          }
          die.quaternion.setFromEuler(euler);
          die.userData.velocity.set(0, 0, 0);
          die.userData.angularVelocity.set(0, 0, 0);
        }
      });
    }

    function displayResults() {
      const rollLog = document.getElementById('roll-log');
      const resultsByType = {};
      let totalSum = 0;
      dice.forEach(die => {
        const type = die.userData.type;
        const result = die.userData.result;
        if (!resultsByType[type]) {
          resultsByType[type] = [];
        }
        resultsByType[type].push(result);
        totalSum += result;
      });
      let resultHTML = '';
      for (const type in resultsByType) {
        if (resultsByType[type].length > 0) {
          resultHTML += `<span class="${type}-result">${type.toUpperCase()}: [${resultsByType[type].join(', ')}]</span> `;
        }
      }
      resultHTML += `<span class="total-result">Total: ${totalSum}</span>`;
      const logEntry = document.createElement('li');
      logEntry.innerHTML = resultHTML;
      rollLog.insertBefore(logEntry, rollLog.firstChild);
      while (rollLog.children.length > 10) {
        rollLog.removeChild(rollLog.lastChild);
      }
    }

    function copyLog() {
      const rollLog = document.getElementById('roll-log');
      let logText = '';
      for (let i = 0; i < rollLog.children.length; i++) {
        logText += rollLog.children[i].textContent.trim() + '\n';
      }
      navigator.clipboard.writeText(logText)
        .then(() => { alert('Roll log copied to clipboard!'); })
        .catch(err => { console.error('Failed to copy log:', err); });
    }

    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
      canvasContainer.appendChild(renderer.domElement);
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const pointLight = new THREE.PointLight(0xffffff, 1);
      pointLight.position.set(10, 10, 10);
      scene.add(pointLight);
      camera.position.z = 18;
      camera.position.y = 8;
      function createStars() {
        const starCount = 1000;
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        for (let i = 0; i < starCount; i++) {
          const x = Math.random() * 2000 - 1000;
          const y = Math.random() * 2000 - 1000;
          const z = Math.random() * 2000 - 1000;
          starVertices.push(x, y, z);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
      }
      createStars();
      const redPlaneGeometry = new THREE.PlaneGeometry(borderSize, borderSize);
      const redPlaneMaterial = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        roughness: 0.8,
        metalness: 0.2
      });
      const redPlane = new THREE.Mesh(redPlaneGeometry, redPlaneMaterial);
      redPlane.rotation.x = -Math.PI / 2;
      redPlane.position.y = floorY;
      scene.add(redPlane);
      const blackPlaneGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
      const blackPlaneMaterial = new THREE.MeshStandardMaterial({
        color: 0x000000,
        roughness: 0.8,
        metalness: 0.2
      });
      const blackPlane = new THREE.Mesh(blackPlaneGeometry, blackPlaneMaterial);
      blackPlane.rotation.x = -Math.PI / 2;
      blackPlane.position.y = floorY + 0.01;
      scene.add(blackPlane);
    }

    let canvasContainer;
    window.addEventListener('load', function() {
      if (typeof THREE === 'undefined') {
        console.error('Three.js failed to load. Check your internet connection or the CDN link.');
        return;
      }
      canvasContainer = document.getElementById('canvas-container');
      initScene();
      document.querySelectorAll('.dice-control .add').forEach(button => {
        button.addEventListener('click', function() {
          const type = this.parentElement.dataset.type;
          addDie(type);
        });
      });
      document.querySelectorAll('.dice-control .remove').forEach(button => {
        button.addEventListener('click', function() {
          const type = this.parentElement.dataset.type;
          removeDie(type);
        });
      });
      document.getElementById('roll-button').addEventListener('click', rollDice);
      document.getElementById('copy-log-button').addEventListener('click', copyLog);
      addDie('d4');
      addDie('d6');
      addDie('d8');
      addDie('d10');
      addDie('d12');
      addDie('d20');
      let lastTime = 0;
      function animate(time) {
        requestAnimationFrame(animate);
        const delta = Math.min((time - lastTime) / 1000, 0.1);
        lastTime = time;
        if (Math.random() < 0.01) {
          const starCount = Math.floor(Math.random() * 3) + 2;
          for (let i = 0; i < starCount; i++) {
            spawnShootingStar();
          }
        }
        updateDicePhysics(delta);
        updateShootingStars(delta);
        renderer.render(scene, camera);
      }
      animate(0);
      window.addEventListener('resize', () => {
        camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
      });
    });
  </script>
</body>
</html>
