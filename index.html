<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D D&D Dice Roller</title>
    <link rel="icon" href="data:,">
    <style>
        body {
            margin: 0;
            background-color: #1a1a1a;
            color: #fff;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        #controls {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }
        .dice-control {
            background-color: #ff4444;
            padding: 10px;
            margin: 5px;
            border-radius: 5px;
            display: flex;
            align-items: center;
        }
        .dice-control span {
            margin: 0 10px;
            color: yellow;
            font-weight: bold;
        }
        .dice-control button {
            background-color: yellow;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            font-weight: bold;
            border-radius: 3px;
        }
        .dice-control button:hover {
            background-color: #e6e600;
        }
        #canvas-container {
            width: 80%;
            height: 50%;
            border: 2px solid yellow;
            background-color: #000;
            position: relative;
        }
        #roll-button {
            margin: 10px 0;
            padding: 10px 20px;
            background-color: #4444ff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        #roll-button:hover {
            background-color: #3333cc;
        }
        #results {
            background-color: #222;
            padding: 10px;
            border: 1px solid yellow;
            border-radius: 5px;
            width: 80%;
            max-height: 200px;
            overflow-y: auto;
            color: #fff;
        }
        #results h3 {
            margin: 0;
            color: yellow;
        }
        #roll-log {
            list-style: none;
            padding: 0;
            margin: 10px 0 0 0;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div class="dice-control" data-type="d4">
            <button class="remove">-</button>
            <span>D4: 0</span>
            <button class="add">+</button>
        </div>
        <div class="dice-control" data-type="d6">
            <button class="remove">-</button>
            <span>D6: 0</span>
            <button class="add">+</button>
        </div>
        <div class="dice-control" data-type="d8">
            <button class="remove">-</button>
            <span>D8: 0</span>
            <button class="add">+</button>
        </div>
        <div class="dice-control" data-type="d10">
            <button class="remove">-</button>
            <span>D10: 0</span>
            <button class="add">+</button>
        </div>
        <div class="dice-control" data-type="d12">
            <button class="remove">-</button>
            <span>D12: 0</span>
            <button class="add">+</button>
        </div>
        <div class="dice-control" data-type="d20">
            <button class="remove">-</button>
            <span>D20: 0</span>
            <button class="add">+</button>
        </div>
    </div>
    <div id="canvas-container"></div>
    <button id="roll-button">Roll</button>
    <div id="results">
        <h3>Recent Rolls</h3>
        <ul id="roll-log"></ul>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        window.addEventListener('load', function() {
            if (typeof THREE === 'undefined') {
                console.error('Three.js failed to load. Check your internet connection or the CDN link.');
                return;
            }

            // Scene setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth * 0.8 / (window.innerHeight * 0.5), 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            const container = document.getElementById('canvas-container');
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            // Camera position
            camera.position.z = 10;

            // Dice management
            const diceTypes = ['d4', 'd6', 'd8', 'd10', 'd12', 'd20'];
            const diceCounts = { d4: 0, d6: 0, d8: 0, d10: 0, d12: 0, d20: 0 };
            const dice = [];

            // Geometries for each dice type
            const geometries = {
                d4: new THREE.TetrahedronGeometry(1),
                d6: new THREE.BoxGeometry(1, 1, 1),
                d8: new THREE.OctahedronGeometry(1),
                d10: new THREE.DodecahedronGeometry(1), // Approximation for D10
                d12: new THREE.DodecahedronGeometry(1),
                d20: new THREE.IcosahedronGeometry(1)
            };

            // Face groups for each die type
            const faceGroups = {
                d4: Array.from({length: 4}, (_, i) => [i]),
                d6: Array.from({length: 6}, (_, i) => [i*2, i*2+1]),
                d8: Array.from({length: 8}, (_, i) => [i]),
                d10: Array.from({length: 12}, (_, i) => [i*3, i*3+1, i*3+2]), // Approximation
                d12: Array.from({length: 12}, (_, i) => [i*3, i*3+1, i*3+2]),
                d20: Array.from({length: 20}, (_, i) => [i])
            };

            // Create number texture
            function createNumberTexture(number) {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'black';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(number.toString(), 32, 32);
                return new THREE.CanvasTexture(canvas);
            }

            // Create a die with numbered faces and normals
            function createDie(type) {
                const geometry = geometries[type];
                const material = new THREE.MeshPhongMaterial({ color: 0xffff00 });
                const diceMesh = new THREE.Mesh(geometry, material);
                diceMesh.faceNormals = [];
                diceMesh.type = type;

                const position = geometry.attributes.position.array;
                const index = geometry.index.array;
                const group = faceGroups[type];

                for (let faceIndex = 0; faceIndex < group.length; faceIndex++) {
                    const triangles = group[faceIndex];
                    let center = new THREE.Vector3(0, 0, 0);
                    let normalSum = new THREE.Vector3(0, 0, 0);
                    for (let tri of triangles) {
                        const idx0 = index[tri * 3];
                        const idx1 = index[tri * 3 + 1];
                        const idx2 = index[tri * 3 + 2];
                        const v0 = new THREE.Vector3(position[idx0 * 3], position[idx0 * 3 + 1], position[idx0 * 3 + 2]);
                        const v1 = new THREE.Vector3(position[idx1 * 3], position[idx1 * 3 + 1], position[idx1 * 3 + 2]);
                        const v2 = new THREE.Vector3(position[idx2 * 3], position[idx2 * 3 + 1], position[idx2 * 3 + 2]);
                        const triCenter = new THREE.Vector3().add(v0).add(v1).add(v2).divideScalar(3);
                        center.add(triCenter);
                        const edge1 = new THREE.Vector3().subVectors(v1, v0);
                        const edge2 = new THREE.Vector3().subVectors(v2, v0);
                        const triNormal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
                        normalSum.add(triNormal);
                    }
                    center.divideScalar(triangles.length);
                    normalSum.normalize();
                    diceMesh.faceNormals.push(normalSum.clone());

                    const number = faceIndex + 1;
                    const numberTexture = createNumberTexture(number);
                    const numberMaterial = new THREE.MeshBasicMaterial({ map: numberTexture, transparent: true });
                    const planeGeometry = new THREE.PlaneGeometry(0.3, 0.3);
                    const numberMesh = new THREE.Mesh(planeGeometry, numberMaterial);
                    const offset = 0.01;
                    numberMesh.position.copy(center).add(normalSum.multiplyScalar(offset));
                    numberMesh.lookAt(center.clone().add(normalSum));
                    diceMesh.add(numberMesh);
                }

                diceMesh.rotationSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                );
                diceMesh.isRolling = false;
                diceMesh.rollTime = 0;
                return diceMesh;
            }

            // Add a die
            function addDie(type) {
                if (diceCounts[type] < 10) {
                    diceCounts[type]++;
                    const die = createDie(type);
                    scene.add(die);
                    dice.push(die);
                    positionDice();
                    updateControls();
                }
            }

            // Remove a die
            function removeDie(type) {
                if (diceCounts[type] > 0) {
                    diceCounts[type]--;
                    const index = dice.findIndex(d => d.type === type);
                    if (index !== -1) {
                        scene.remove(dice[index]);
                        dice.splice(index, 1);
                    }
                    positionDice();
                    updateControls();
                }
            }

            // Position dice
            function positionDice() {
                const spacing = 2.5;
                dice.forEach((die, index) => {
                    die.position.set((index - dice.length / 2) * spacing, 0, 0);
                });
            }

            // Update controls UI
            function updateControls() {
                diceTypes.forEach(type => {
                    const control = document.querySelector(`.dice-control[data-type="${type}"] span`);
                    control.textContent = `${type.toUpperCase()}: ${diceCounts[type]}`;
                });
            }

            // Add control listeners
            document.querySelectorAll('.dice-control .add').forEach(button => {
                button.addEventListener('click', () => {
                    const type = button.parentElement.dataset.type;
                    addDie(type);
                });
            });
            document.querySelectorAll('.dice-control .remove').forEach(button => {
                button.addEventListener('click', () => {
                    const type = button.parentElement.dataset.type;
                    removeDie(type);
                });
            });

            // Roll button logic
            document.getElementById('roll-button').addEventListener('click', () => {
                if (dice.length === 0) return;
                dice.forEach(die => {
                    die.isRolling = true;
                    die.rollTime = 0;
                    die.rotationSpeed.set(
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.2
                    );
                });
                setTimeout(() => {
                    dice.forEach(die => {
                        die.isRolling = false;
                        const faces = parseInt(die.type.slice(1));
                        die.rollResult = Math.floor(Math.random() * faces) + 1;
                        const faceIndex = die.rollResult - 1;
                        const desiredNormal = die.faceNormals[faceIndex];
                        const up = new THREE.Vector3(0, 1, 0);
                        const quaternion = new THREE.Quaternion().setFromUnitVectors(desiredNormal, up);
                        die.quaternion.copy(quaternion);
                    });
                    displayResults();
                }, 2000);
            });

            // Display results in log
            function displayResults() {
                const rollLog = document.getElementById('roll-log');
                const results = dice.map((die, index) => `Dice ${index + 1} (${die.type}): ${die.rollResult}`).join(', ');
                const total = dice.reduce((sum, die) => sum + die.rollResult, 0);
                const logEntry = document.createElement('li');
                logEntry.textContent = `Roll: ${results} | Total: ${total}`;
                rollLog.insertBefore(logEntry, rollLog.firstChild);
                while (rollLog.children.length > 8) {
                    rollLog.removeChild(rollLog.lastChild);
                }
            }

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                dice.forEach(die => {
                    if (die.isRolling) {
                        die.rotation.x += die.rotationSpeed.x;
                        die.rotation.y += die.rotationSpeed.y;
                        die.rotation.z += die.rotationSpeed.z;
                    }
                });
                renderer.render(scene, camera);
            }
            animate();

            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        });
    </script>
</body>
</html>
